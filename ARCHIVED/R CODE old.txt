## 1. Set working directory and load in the data. Also view snippets of the data
setwd("C:\\Users\\USER\\Documents\\RWORK") 
getwd()
## 2. Install and load required packages 
if(!require(seminr)) install.packages("seminr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(semPlot)) install.packages("semPlot", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(dplyr)) install.packages("dplyr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(tibble)) install.packages("tibble", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(readr)) install.packages("readr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(ggplot2)) install.packages("ggplot2", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(lavaan)) install.packages("lavaan", repos="https://cloud.r-project.org") # Skip if already installed
# if(!require(readxl)) install.packages("readxl", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(openxlsx)) install.packages("openxlsx", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(DiagrammeR)) install.packages("DiagrammeR", repos="https://cloud.r-project.org") # Skip if already installed

library(tibble)
# library(readxl) # Import an Excel file
library(readr)
library(ggplot2)
library(seminr)
library(semPlot)
library(dplyr)
library(lavaan)
library(DiagrammeR)
library(openxlsx)

set.seed(123)


## Set the theme to use
thm <- seminr_theme_create(
	plot.rounding = 2,
	plot.adj = FALSE,
	sm.node.fill = "#3190EF", # Picton blue
	mm.node.fill = "#F2F273") # Manz - close to yellow
## Use the theme in the R Studio session
seminr_theme_set(thm) # Use autocomplete to discover all possible theme options!


################################################# Objective One #################################################################
# dt <- read_excel("PROMISE V1 Excel.xlsx") # Attempt to use an Excel file

dt <- read.csv("PROMISE V1 CSV.csv", header = TRUE, sep = ",")
head(dt)
tail(dt)
View(dt)
glimpse(dt)
class(dt)

## 3. Define measurement model

mm <- constructs(
  composite("MAT", multi_items("MAT", 1:5), weights = mode_A),
  composite("OP",  multi_items("OP", 1:5), weights = mode_A)
)


## 4. Structural model
sm <- relationships(
  paths(from = "MAT", to = "OP"))

  
  ## 5. Estimate model
  pls_model <- estimate_pls(data = dt, measurement_model = mm, structural_model = sm,inner_weights = path_weighting,
   missing = mean_replacement,
  missing_value = "-99")

  summary(pls_model)
  
  paths <- pls_model$path_coefficients # MAY DELETE
  print(paths) # MAY DELETE
  paths_coeff <- pls_model$paths$coefficients # MAY DELETE 
  
  print(paths_coeff) # MAY DELETE 

  
  ### 6. Summarizing the model
  # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.
  summary_pls_model <- summary(pls_model)
  

  #### calling summary_pls_model$total_effects, we inspect the model's total effects
   summary_pls_model$total_effects

  #### calling summary_pls_model$total_indirect_effects, we inspect the model's total indirect effects
   summary_pls_model$total_indirect_effects

  #### calling summary_pls_model$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
  summary_pls_model$paths
  
  #### calling summary_pls_model$reliability, we inspect the construct reliability metrics
  summary_pls_model$reliability
  
  
  #### we can plot the reliability
  plot(summary_pls_model$reliability)
  
  if(requireNamespace("car", quietly = TRUE)) {
    library(car)
    # Note: seminr does not directly give VIF; can compute VIF using construct scores
    lm1 <- lm(OP ~ MAT , data = dt)
    vif_vals <- car::vif(lm1)
    print(vif_vals)
    write_csv(as.data.frame(vif_vals), "pls_vif_innermodel.csv")
  }


 #### calling summary_pls_model$validity, we inspect the construct validity metrics # Check this out first to see contents
  summary_pls_model$validity

  #### calling summary_pls_model$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
  summary_pls_model$validity$fl_criteria
  
  #### Calling summary_pls_model$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
  summary_pls_model$validity$htmt
  
  
  ### Calling summary_pls_model$vif_antecedents, we inspect the VIF for collinearity
  summary_pls_model$vif_antecedents
  
  ### To get VIF # Option 2 - Compare with the first one above
  summary_pls_model$validity$vif_items
  

  #### We can access summary statistics of the model’s items
  items_statistics_summary_pls_model<- summary_pls_model$descriptives$statistics$items
  items_statistics_summary_pls_model
 
  
  #### To get the construct statistics.
  constructs_statistics_summary_pls_model <-  summary_pls_model$descriptives$statistics$constructs
  constructs_statistics_summary_pls_model
  
  ##. Outer loadings (indicator reliability)
  pls_model$outer_loadings
  
   ## Or
  outer_loadings_pls_model <- summary_pls_model$loadings
  print(outer_loadings_pls_model)
  
   
   ##. weights
   pls_model$outer_weights
   
   # Or
   weights_pls_model <- summary_pls_model$weights
   print(weights_pls_model)
   
   # Compute cross-loadings manually. Cross-loading is a correlation between the data itself and the construct score
   cross_loadings_pls_model <- cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs")
   
   # Round for neatness
   round(cross_loadings_pls_model, 4)
   
   
   # To get the effect size
   fsquare_pls_model  <- summary_pls_model$fSquare
   fsquare_pls_model
   
  ##. Construct scores (latent variable scores)
  construct_scores1 <- pls_model$scores # Option 1 - Check this out again
  construct_scores1
  
 construct_scores2 <-  pls_model$construct_scores # Option 2 
 construct_scores2

 construct_scores3 <-  summary_pls_model$composite_scores # Option 3  - Check this out again
 construct_scores3



# Saving the PL-SEM results to file

## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
summary_pls_model <- summary(pls_model)

# Extract key components
total_effects <- summary_pls_model$total_effects
total_indirect_effects <- summary_pls_model$total_indirect_effects
paths        <- summary_pls_model$paths
loadings     <- summary_pls_model$loadings
cross_loadings <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights      <- summary_pls_model$weights
rSquared     <- summary_pls_model$rSquared
reliability  <- summary_pls_model$reliability
htmt         <- summary_pls_model$htmt
fSquare      <- summary_pls_model$fSquare
collinearity <- summary_pls_model$validity$vif_items
collinearity2<- summary_pls_model$vif_antecedents
fornell_larcker <-  summary_pls_model$validity$fl_criteria
items_statistics <- summary_pls_model$descriptives$statistics$items

### Write each to CSV
write.csv(total_effects,  "total_effects.csv", row.names = TRUE)
write.csv(total_indirect_effects, "total_indirect_effects.csv", row.names = TRUE)
write.csv(paths,       "paths.csv", row.names = TRUE)
write.csv(loadings,    "loadings.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings.csv", row.names = TRUE)
write.csv(weights,     "weights.csv", row.names = TRUE)
write.csv(rSquared,    "rSquared.csv", row.names = TRUE)
write.csv(reliability, "reliability.csv", row.names = TRUE)
write.csv(htmt,        "htmt.csv", row.names = TRUE)
write.csv(fSquare,     "fSquare.csv", row.names = TRUE)
write.csv(collinearity, "collinearity.csv", row.names = TRUE)
write.csv(collinearity2, "collinearity2.csv", row.names = TRUE)
write.csv(fornell_larcker,"fornell_larcker.csv", row.names = TRUE)
write.csv(items_statistics,"items_statistics.csv", row.names = TRUE)



## Summarize the PLS-SEM model outputs and take them to a single Excel file

wb <- createWorkbook()
addWorksheet(wb, "total_effects"); writeData(wb, "total_effects", summary_pls_model$total_effects)
addWorksheet(wb, "total_indirect_effects"); writeData(wb, "total_indirect_effects", summary_pls_model$total_indirect_effects)
addWorksheet(wb, "Paths");        writeData(wb, "Paths", summary_pls_model$paths)
addWorksheet(wb, "Loadings");     writeData(wb, "Loadings", summary_pls_model$loadings)
addWorksheet(wb, "cross_loadings");     writeData(wb, "cross_loadings", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4))
addWorksheet(wb, "Weights");      writeData(wb, "Weights", summary_pls_model$weights)
addWorksheet(wb, "RSquared");     writeData(wb, "RSquared", summary_pls_model$rSquared)
addWorksheet(wb, "Reliability");  writeData(wb, "Reliability", summary_pls_model$reliability)
addWorksheet(wb, "HTMT");         writeData(wb, "HTMT", summary_pls_model$htmt)
addWorksheet(wb, "fSquare");      writeData(wb, "fSquare", summary_pls_model$fSquare)
addWorksheet(wb, "collinearity");  writeData(wb, "collinearity", summary_pls_model$validity$vif_items)
addWorksheet(wb, "collinearity2"); writeData(wb, "collinearity2", summary_pls_model$vif_antecedents)
addWorksheet(wb, "fornell_larcker"); writeData(wb, "fornell_larcker", summary_pls_model$validity$fl_criteria)
addWorksheet(wb, "items_statistics"); writeData(wb, "items_statistics", summary_pls_model$descriptives$statistics$items)

saveWorkbook(wb, "Promise Objective 1.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
summary_pls_model <- summary(pls_model)

# Extract key components
total_effects <- summary_pls_model$total_effects
total_indirect_effects <- summary_pls_model$total_indirect_effects
paths        <- summary_pls_model$paths
loadings     <- summary_pls_model$loadings
cross_loadings <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights      <- summary_pls_model$weights
rSquared     <- summary_pls_model$rSquared
reliability  <- summary_pls_model$reliability
htmt         <- summary_pls_model$htmt
fSquare      <- summary_pls_model$fSquare
collinearity <- summary_pls_model$validity$vif_items
collinearity2<- summary_pls_model$vif_antecedents
fornell_larcker <-  summary_pls_model$validity$fl_criteria
items_statistics <- summary_pls_model$descriptives$statistics$items

# Write each to CSV
write.csv(total_effects,  "total_effects.csv", row.names = TRUE)
write.csv(total_indirect_effects, "total_indirect_effects.csv", row.names = TRUE)
write.csv(paths,       "paths.csv", row.names = TRUE)
write.csv(loadings,    "loadings.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings.csv", row.names = TRUE)
write.csv(weights,     "weights.csv", row.names = TRUE)
write.csv(rSquared,    "rSquared.csv",row.names = TRUE)
write.csv(reliability, "reliability.csv", row.names = TRUE)
write.csv(htmt,        "htmt.csv", row.names = TRUE)
write.csv(fSquare,     "fSquare.csv", row.names = TRUE)
write.csv(collinearity, "collinearity.csv", row.names = TRUE)
write.csv(collinearity2, "collinearity2.csv", row.names = TRUE)
write.csv(fornell_larcker,"fornell_larcker.csv", row.names = TRUE)
write.csv(items_statistics,"items_statistics.csv", row.names = TRUE)



## Summarize the PLS-SEM model outputs and take them to a single Excel file

### Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)


wb <- createWorkbook()
addWorksheet(wb, "total_effects"); writeData(wb, "total_effects", summary_pls_model$total_effects, headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects"); writeData(wb, "total_indirect_effects", summary_pls_model$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths");        writeData(wb, "Paths", summary_pls_model$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings");     writeData(wb, "Loadings", summary_pls_model$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings");     writeData(wb, "cross_loadings", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle = 															header_style, borders = "all")
addWorksheet(wb, "Weights");      writeData(wb, "Weights", summary_pls_model$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared");     writeData(wb, "RSquared", summary_pls_model$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability");  writeData(wb, "Reliability", summary_pls_model$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT");         writeData(wb, "HTMT", summary_pls_model$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare");      writeData(wb, "fSquare", summary_pls_model$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity");  writeData(wb, "collinearity", summary_pls_model$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2"); writeData(wb, "collinearity2", summary_pls_model$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker"); writeData(wb, "fornell_larcker", summary_pls_model$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics"); writeData(wb, "items_statistics", summary_pls_model$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")

saveWorkbook(wb, "Promise Objective 1.xlsx", overwrite = TRUE)


####################### FORMATTED VERSION WITH FUNCTION ##########################################################################

# --- Create workbook ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}

# --- PLS model results ---
addWorksheet(wb, "total_effects"); writeData(wb, "total_effects", summary_pls_model$total_effects, headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects"); writeData(wb, "total_indirect_effects", summary_pls_model$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths");        writeData(wb, "Paths", summary_pls_model$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings");     writeData(wb, "Loadings", summary_pls_model$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings");     writeData(wb, "cross_loadings", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle = 															header_style, borders = "all")
addWorksheet(wb, "Weights");      writeData(wb, "Weights", summary_pls_model$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared");     writeData(wb, "RSquared", summary_pls_model$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability");  writeData(wb, "Reliability", summary_pls_model$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT");         writeData(wb, "HTMT", summary_pls_model$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare");      writeData(wb, "fSquare", summary_pls_model$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity");  writeData(wb, "collinearity", summary_pls_model$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2"); writeData(wb, "collinearity2", summary_pls_model$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker"); writeData(wb, "fornell_larcker", summary_pls_model$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics"); writeData(wb, "items_statistics", summary_pls_model$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")


# ---  Save workbook ---
saveWorkbook(wb, "Promise Objective 1.xlsx", overwrite = TRUE)

message("✅ Export complete: PLS results written to Promise Objective 1.xlsx")


  # Bootstrapping the results

  boot_model <- bootstrap_model(seminr_model = pls_model,
                                nboot = 1000,
                                cores = NULL,
                                seed = 123)
  
  sum_boot_model <- summary(boot_model, , alpha = 0.05)
  
  #### Obtain bootstrapping results on model estimates such as the path coefficients with sum_boot_model$bootstrapped_paths.

  ######## Get the P-value and save the bootstrapping result to csv #################################
  
 sum_boot_paths <- sum_boot_model$bootstrapped_paths

 ### Check the class of  sum_boot_paths

class(sum_boot_paths)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_paths)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths) <- NULL

# Make Path the first column
sum_boot_paths  <- sum_boot_paths[, c("Path", setdiff(names(sum_boot_paths), "Path"))]


# Convert bootstrap results to data.frame 
  sum_boot_paths <- as.data.frame(sum_boot_paths)
  sum_boot_paths # Print to see the content

  
 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once

sum_boot_paths <- as.data.frame(sum_boot_paths) %>% 
  rownames_to_column(var = "Path")


  # Compute p-values (using "T Stat." column with dot)
  sum_boot_paths$p_value <- round(2 * (1 - pnorm(abs(sum_boot_paths[,"T Stat."]))),4)
  
  ### Get the column headers
  colnames(sum_boot_paths)
  head(sum_boot_paths)
  
  # Add significance levels
  sum_boot_paths$Significance <- cut(
    sum_boot_paths$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  

  # Create a clean table with selected columns
  paths_clean_results <- sum_boot_paths[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                      "2.5% CI","97.5% CI", "p_value" ,      
                                      "Significance" )]
  
  # Rename columns for clarity
  colnames(paths_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                "2.5% CI","97.5% CI", "p_value" ,      
                                "Significance" )
    
  
  # Export to CSV (saves in working directory)
  write.csv(
    paths_clean_results,
    file = "paths_bootstrap_results.csv",
    row.names = TRUE
  )
  
  # Confirm location
  cat("✅ Clean results with CIs saved as 'bootstrap_results.csv' in your working directory\n")
  
  
  
  ###### Writing the path bootstrapping as a function (optional)
  
  export_path_bootstrap_results <- function(pathbootstrap, filename = "path_bootstrap_results.csv") {
    sum_boot_paths <- sum_boot_model$bootstrapped_paths

 ### Check the class of  sum_boot_paths

class( sum_boot_paths)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_paths)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths) <- NULL

# Make Path the first column
sum_boot_paths  <- sum_boot_paths [, c("Path", setdiff(names(sum_boot_paths), "Path"))]



# Convert bootstrap results to data.frame 
  sum_boot_paths <- as.data.frame(sum_boot_paths)
  sum_boot_paths # Print to see the content
    
    # Compute p-values (using "T Stat." column with dot)
    sum_boot_paths$p_value <- 2 * (1 - pnorm(abs(sum_boot_paths[,"T Stat."])))
    
    # Add significance levels

    sum_boot_paths$Significance <- cut(
      sum_boot_paths$p_value,
      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
      labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
    )
    
    # Create a clean table with selected columns
    paths_clean_results <- sum_boot_paths[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                        "2.5% CI","97.5% CI", "p_value" ,      
                                        "Significance" )]
    
    # Rename columns for clarity
    colnames(paths_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                  "2.5% CI","97.5% CI", "p_value" ,      
                                  "Significance" )
    
    # Export to CSV
    write.csv(
      paths_clean_results,
      file = "paths_bootstrap_results.csv",
      row.names = TRUE
    )
    
    # Confirm location
    cat("✅ Clean results with CIs saved as 'path_bootstrap_results.csv' in your working directory\n")
    
  cat("✅ Path bootstrap results exported \n")
  }
  
  export_path_bootstrap_results(pathbootstrap)
  
  
  #### Bootstrapping of outer loadings 

  ####### Get the P-value and save the bootstrapping result to csv #################################
 

 sum_boot_loadings  <- sum_boot_model$bootstrapped_loadings

 ### Check the class of  sum_boot_loadings

class(sum_boot_loadings)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_loadings)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_loadings)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_loadings) <- NULL

# Make Loadings the first column 
sum_boot_loadings <- sum_boot_loadings [, c("Loadings", setdiff(names(sum_boot_loadings), "Loadings"))]

# Convert bootstrap results to data.frame 
  sum_boot_loadings <- as.data.frame(sum_boot_loadings)
  sum_boot_loadings  # Print to see the content

  
 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once
sum_boot_loadings<- as.data.frame(sum_boot_loadings) %>%  
  rownames_to_column(var = "Loadings") # Won’t be used inside the function version at the same time as the above 



  # Compute p-values (using "T Stat." column with dot)
  sum_boot_loadings$p_value <- round(2 * (1 - pnorm(abs(sum_boot_loadings[,"T Stat."]))),4)
  
  ### Get the column headers
  colnames(sum_boot_loadings)
  head(sum_boot_loadings)
  
  # Add significance levels
  sum_boot_loadings$Significance <- cut(
    sum_boot_loadings$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  
  # Create a clean table with selected columns
  loadings_clean_results <- sum_boot_loadings[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                      "2.5% CI","97.5% CI", "p_value" ,      
                                      "Significance" )]
  
  # Rename columns for clarity
  colnames(loadings_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                "2.5% CI","97.5% CI", "p_value" ,      
                                "Significance" )
    
  
  # Export to CSV (saves in working directory)
  write.csv(
    loadings_clean_results,
    file = "loadings_boostrap_result.csv",
    row.names = TRUE
  )
  
  # Confirm location
  cat("✅ Clean results of loadings with CIs saved as 'outer_loadings_boostrap.csv' in your working directory\n")
 


###### Writing the loadings bootstrapping as a function (optional)


  
  export_loadings_bootstrap_results <- function(loadingsbootstrap, filename = "loadings_bootstrap_results.csv") {
    sum_boot_loadings <- sum_boot_model$bootstrapped_loadings

 ### Check the class of  sum_boot_loadings

class( sum_boot_loadings)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_loadings)

# Now create a column for the rownames 
sum_boot_paths$Loadings <- rownames(sum_boot_loadings)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_loadings) <- NULL

# Make Path the first column
sum_boot_loadings  <- sum_boot_loadings[, c("Loadings", setdiff(names(sum_boot_loadings), "Loadings"))]



# Convert bootstrap results to data.frame 
  sum_boot_loadings <- as.data.frame(sum_boot_loadings)
  sum_boot_loadings # Print to see the content
    
    # Compute p-values (using "T Stat." column with dot)
    sum_boot_loadings$p_value <- 2 * (1 - pnorm(abs(sum_boot_loadings[,"T Stat."])))
    
    # Add significance levels

    sum_boot_loadings$Significance <- cut(
      sum_boot_loadings$p_value,
      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
      labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
    )
    
    # Create a clean table with selected columns
    loadings_clean_results <- sum_boot_loadings[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                        "2.5% CI","97.5% CI", "p_value" ,      
                                        "Significance" )]
    
    # Rename columns for clarity
    colnames(loadings_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                  "2.5% CI","97.5% CI", "p_value" ,      
                                  "Significance" )
    
    # Export to CSV
    write.csv(
      loadings_clean_results,
      file = "loadings_bootstrap_results.csv",
      row.names = TRUE
    )
    
    # Confirm location
    cat("✅ Clean results with CIs saved as 'loadings_bootstrap_results.csv' in your working directory\n")
    
  cat("✅ Loadings bootstrap results exported \n")
  }
  
  export_loadings_bootstrap_results(loadingsbootstrap)
  



# Saving the bootstrapping results to file

## Summarize the PLS-SEM Bootstrapping outputs and take them to their respective CSV files

### Extract key components
sum_boot_paths <- sum_boot_paths # No need to run the sum_boot_model$sum_boot_paths again, # since one containing the p-value and significance is available above

sum_boot_loadings <-  sum_boot_loadings # No need to run the sum_boot_model$sum_boot_loadings again, since one containing the p-value and     	#significance is available above

sum_boot_weights  <- sum_boot_model$bootstrapped_weights
sum_boot_HTMT     <- sum_boot_model$bootstrapped_HTMT


### Write each to CSV
write.csv(sum_boot_paths,  "boot_paths.csv", row.names = TRUE)
write.csv(sum_boot_loadings,  "boot_loadings.csv", row.names = TRUE)
write.csv(sum_boot_weights,  "boot_weights.csv", row.names = TRUE)
write.csv(sum_boot_HTMT,  "boot_HTMT.csv", row.names = TRUE)


## Summarize the PLS-SEM Bootstrapping model outputs and take them to a single Excel file
wb <- createWorkbook()
add_sheet(wb, "sum_boot_paths",     sum_boot_paths)  # We need not run sum_boot_model$bootstrapped_paths again. Available above
add_sheet(wb, "sum_boot_loadings",  sum_boot_loadings) # We need not run sum_boot_model$bootstrapped_loadings again. Available above
add_sheet(wb, "sum_boot_weights",   sum_boot_model$bootstrapped_weights)
add_sheet(wb, "sum_boot_HTMT",      sum_boot_model$bootstrapped_HTMT)

saveWorkbook(wb, "Promise Obj 1_Bootstrap.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


# Summarize the PLS-SEM bootstrap outputs and take them to their respective CSV files


# Extract key components
sum_boot_paths <- sum_boot_paths # We need not run sum_boot_model$bootstrapped_paths again. Available above
sum_boot_loadings <-  sum_boot_loadings # We need not run sum_boot_model$bootstrapped_loadings again. Available above
sum_boot_weights  <- sum_boot_model$bootstrapped_weights
sum_boot_HTMT     <- sum_boot_model$bootstrapped_HTMT


# Write each to CSV
write.csv(sum_boot_paths,  "boot_paths.csv", row.names = TRUE)
write.csv(sum_boot_loadings,  "boot_loadings.csv", row.names = TRUE)
write.csv(sum_boot_weights,  "boot_weights.csv", row.names = TRUE)
write.csv(sum_boot_HTMT,  "boot_HTMT.csv", row.names = TRUE)



# Summarize the PLS-SEM bootstrapping outputs and take them to a single Excel file

# Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

wb <- createWorkbook()

# --- Bootstrap results ---
add_sheet(wb, "sum_boot_paths",     sum_boot_paths, headerStyle = header_style, borders = "all") # We need not run #sum_boot_model$bootstrapped_paths again

add_sheet(wb, "sum_boot_loadings",  sum_boot_loadings, headerStyle = header_style, borders = "all")  # We need not run #sum_boot_model$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights",   sum_boot_model$bootstrapped_weights, headerStyle = header_style, borders = "all")
add_sheet(wb, "sum_boot_HTMT",      sum_boot_model$bootstrapped_HTMT, headerStyle = header_style, borders = "all")

saveWorkbook(wb, "Promise Obj 1_Bootstrap.xlsx", overwrite = TRUE)



####################### FORMATTED VERSION WITH FUNCTION - BOOTSTRAPPING ######################################

# --- Create workbook for bootstrapping ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4F81BD",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}


# --- Bootstrap results ---
add_sheet(wb, "sum_boot_paths",     sum_boot_paths) # We need not run #sum_boot_model$bootstrapped_paths again

add_sheet(wb, "sum_boot_loadings",  sum_boot_loadings) # We need not run #sum_boot_model$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights",   sum_boot_model$bootstrapped_weights)
add_sheet(wb, "sum_boot_HTMT",      sum_boot_model$bootstrapped_HTMT)

# --- Save workbook ---
saveWorkbook(wb, "Promise PLS_SEM_with_Bootstrap-1 .xlsx", overwrite = TRUE)

message("✅ Export complete: Bootstrap results written to Promise Obj 1_Bootstrap.xlsx")



  # Create the Visualization
  
 plot(pls_model,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()


# The bootstrapped model can also be visualized

 plot(boot_model,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()


# To save plot, we can also use:
# save_plot("plotname.png")




### Use of Lavaan package for analysis

  
lavms1 <- 
    # lavaan version
    model_lavaan <- '
  # Measurement model
  MAT =~ MAT1 + MAT2 + MAT3 + MAT4 + MAT5
  OP  =~ OP1 + OP2 + OP3 + OP4 + OP5
 

  # Structural model
  OP ~ MAT
'
  fit <- sem(lavms1, data = dt)
  semPlot::semPaths(fit, "std", whatLabels = "std")
  
  
  ## 9. Use semPlot's semPaths function for visualization
  semPaths(
    object       = fit,    # seminr model
    what         = "path",       # show path model
    whatLabels   = "est",        # show estimates
    style        = "lisrel",     # clean LISREL-style layout
    edge.label.cex = 1.0,        # font size for path coefficients
    sizeMan      = 6,            # indicator box size
    sizeLat      = 8,            # latent variable size
    residuals    = FALSE,        # hide residual arrows
    intercepts   = FALSE,        # hide intercepts
    layout       = "tree",       # top-down or left-right tree layout
    color        = list(lat = "blue", man = "yellow"), # node colors
    nCharNodes   = 0,            # don't shorten names
    asize        = 2,            # arrow thickness
    edge.color   = "black"       # arrow color
  )
  
  # Convert to semPlot-compatible object
 # sem_model <- semPlot::semPlotModel(fit)
  
  # Save to PNG
  
  ## 10. Save the plot as PNG
  png("pls_path_model_publication_ready1.png", width = 1600, height = 1000, res = 150)
  semPaths(
    object       = fit,
    what         = "path",
    whatLabels   = "est",
    style        = "lisrel",
    edge.label.cex = 1.2,
    sizeMan      = 6,
    sizeLat      = 8,
    residuals    = FALSE,
    intercepts   = FALSE,
    layout       = "tree",
    color        = list(lat = "blue", man = "yellow"),
    nCharNodes   = 0,
    asize        = 2,
    edge.color   = "black"
  )
  dev.off()
  


  #######################################  Objective 2 - Moderation #############################################
  ## Create the measurement model
  
  mm_mod <- constructs(
    composite("MAT", multi_items("MAT", 1:5), weights = mode_A),
    composite("OP",  multi_items("OP", 1:5), weights = mode_A),
    composite("FL",  multi_items("FL", 1:4), weights = mode_A),
    interaction_term(iv = "MAT", moderator = "FL", method = product_indicator)) # You can also use methods like product_indicator or orthogonal

  
  ## Create the structural model
  sm_mod <- relationships(
    paths(from = "MAT", to = "OP"),
    paths(from = c("MAT", "FL", "MAT*FL"), to = "OP") # Interaction of independent and moderating variable
  )
  
  ## Create the structural model - Method 2
  sm_mod <- relationships(
    paths(from = "MAT", to = "OP"),
    paths(from = "MAT", to = "OP"),
    paths(from = "MAT*FL", to = "OP") # Interaction of independent and moderating variable
  )
  
  
  ### Check the constructs
  # mm_mod
  
  
  # Next, we estimate the model with estimate_pls(), store it to pl_sm_mod and summarize it to sum_pls_mod. Further, we also apply bootstrapping and summarize the bootstrapped model with an alpha level of 5% 
  
  ## Estimate the new model with moderator
  pl_sm_mod <- estimate_pls(
    data = dt,
    measurement_model = mm_mod,
    structural_model = sm_mod,
    missing = mean_replacement,
    missing_value = "-99"
  )
  
  ## Extract the summary
  sum_pls_mod <- summary(pl_sm_mod)


  #### calling sum_pls_mod$total_effects, we inspect the model's total effects
   sum_pls_mod$total_effects

  #### calling summary_pls_mod$total_indirect_effects, we inspect the model's total indirect effects

   sum_pls_mod$total_indirect_effects

  
  #### calling summary_pls_model$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
  sum_pls_mod$paths
  
  #### calling summary_pls_model$reliability, we inspect the construct reliability metrics
  sum_pls_mod$reliability
  
  
  #### we can plot the reliability
  plot(sum_pls_mod$reliability)
  
  #### calling summary_pls_model$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
  sum_pls_mod$validity$fl_criteria
  
  #### Calling summary_pls_model$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
  sum_pls_mod$validity$htmt
  
  
  ### Calling summary_pls_model$vif_antecedents, we inspect the VIF for collinearity
  sum_pls_mod$vif_antecedents
  
  ### To get VIF
  sum_pls_mod$validity$vif_items
  
  if(requireNamespace("car", quietly = TRUE)) {
    library(car)
    # Note: seminr does not directly give VIF; can compute VIF using construct scores
    lm2 <- lm(Loyalty ~ Satisfaction + Trust, data = construct_scores)
    vif_vals <- car::vif(lm2)
    print(vif_vals)
    write_csv(as.data.frame(vif_vals), "pls_vif_innermodel.csv")
  }
  
  
  #### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
  sum_pls_mod$descriptives$statistics$items
  
  ##. Outer loadings (indicator reliability)
  sum_pls_mod$loadings
  
  ## Or
  outer_loadings_pl_sm_mod <- pl_sm_mod$outer_loadings
  print(outer_loadings_pl_sm_mod)
  
  
  ##. weights
  pl_sm_mod$outer_weights
  
  # Or
  outer_weights_pl_sm_mod <- sum_pls_mod$weights
  print(outer_weights_pl_sm_mod)
  
  # Compute cross-loadings manually
  cross_loadings_pl_sm_mod <- cor(dt, pl_sm_mod$construct_scores, use = "pairwise.complete.obs")
  
  # Round for neatness
  round(cross_loadings_pl_sm_mod, 4)
  
  
  # To get the effect size
  fsqaure_pls_mod  <- sum_pls_mod$fSquare
  
  
  #### To get the construct statistics.
  sum_pls_mod$descriptives$statistics$constructs
  
  
  #### calling summary_pls_model$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
  sum_pls_mod$paths
  
  #### calling summary_pls_model$reliability, we inspect the construct reliability metrics
  sum_pls_mod$reliability
  
  
  #### we can plot the reliability
  plot(sum_pls_mod$reliability)
  
  
  #### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
  sum_pls_mod$descriptives$statistics$items
  
  
  #### To get the construct statistics.
  sum_pls_mod$descriptives$statistics$constructs
  
  
# Saving the PL-SEM results to file

## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
sum_pls_mod <- summary(pl_sm_mod)

# Extract key components
total_effects_mod <- sum_pls_mod$total_effects
total_indirect_effects_mod _mod <- summary_pls_mod$total_indirect_effects
paths_mod        <- sum_pls_mod$paths
loadings_mod     <- sum_pls_mod$loadings
cross_loadings_mod <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights_mod      <- sum_pls_mod$weights
rSquared_mod     <- sum_pls_mod$rSquared
reliability_mod  <- sum_pls_mod$reliability
htmt_mod         <- sum_pls_mod$htmt
fSquare_mod      <- sum_pls_mod$fSquare
collinearity_mod <- sum_pls_mod$validity$vif_items
collinearity2_mod  <- sum_pls_mod$vif_antecedents
fornell_larcker_mod <-  sum_pls_mod$validity$fl_criteria
items_statistics_mod <- sum_pls_mod$descriptives$statistics$items

### Write each to CSV
write.csv(total_effects_mod ,  "total_effects_mod .csv", row.names = TRUE)
write.csv(total_indirect_effects_mod , "total_indirect_effects_mod .csv", row.names = TRUE)
write.csv(paths_mod,       "paths_mod.csv", row.names = FALSE)
write.csv(loadings_mod,    "loadings_mod.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings.csv", row.names = TRUE)
write.csv(weights_mod,     "weights_mod.csv", row.names = TRUE)
write.csv(rSquared_mod,    "rSquared_mod.csv", row.names = TRUE)
write.csv(reliability_mod, "reliability_mod.csv", row.names = TRUE)
write.csv(htmt_mod,        "htmt_mod.csv", row.names = TRUE)
write.csv(fSquare_mod,     "fSquare_mod.csv", row.names = TRUE)
write.csv(collinearity_mod, "collinearity_mod.csv", row.names = TRUE)
write.csv(collinearity2_mod, "collinearity2_mod.csv", row.names = TRUE)
write.csv(fornell_larcker_mod,"fornell_larcker_mod.csv", row.names = TRUE)
write.csv(items_statistics_mod,"items_statistics_mod.csv", row.names = TRUE)



## Summarize the PLS-SEM model outputs and take them to a single Excel file
wb <- createWorkbook()
addWorksheet(wb, "total_effects_mod"); writeData(wb, "total_effects_mod ", sum_pls_mod$total_effects )
addWorksheet(wb, "total_indirect_effects_mod"); writeData(wb, "total_indirect_effects_mod ", sum_pls_mod$total_indirect_effects)
addWorksheet(wb, "Paths_mod");        writeData(wb, "Paths_mod", sum_pls_mod$paths)
addWorksheet(wb, "Loadings_mod");     writeData(wb, "Loadings_mod", sum_pls_mod$loadings)
addWorksheet(wb, "cross_loadings_mod");     writeData(wb, "cross_loadings_mod", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4))
addWorksheet(wb, "Weights_mod");      writeData(wb, "Weights_mod", sum_pls_mod$weights)
addWorksheet(wb, "RSquared_mod");     writeData(wb, "RSquared_mod", sum_pls_mod$rSquared)
addWorksheet(wb, "Reliability_mod");  writeData(wb, "Reliability_mod", sum_pls_mod$reliability)
addWorksheet(wb, "HTMT_mod");         writeData(wb, "HTMT_mod", sum_pls_mod$htmt)
addWorksheet(wb, "fSquare_mod");      writeData(wb, "fSquare_mod", sum_pls_mod$fSquare)
addWorksheet(wb, "collinearity_mod");  writeData(wb, "collinearity_mod", sum_pls_mod$validity$vif_items)
addWorksheet(wb, "collinearity2_mod"); writeData(wb, "collinearity2_mod", sum_pls_mod$vif_antecedents)
addWorksheet(wb, "fornell_larcker_mod"); writeData(wb, "fornell_larcker_mod", sum_pls_mod$validity$fl_criteria)
addWorksheet(wb, "items_statistics_mod"); writeData(wb, "items_statistics_mod", sum_pls_mod$descriptives$statistics$items)

saveWorkbook(wb, "Promise Objective mod.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
sum_pls_mod <- summary(pl_sm_mod)

# Extract key components
total_effects_mod <- sum_pls_mod$total_effects
total_indirect_effects_mod _mod <- summary_pls_mod$total_indirect_effects
paths_mod        <- sum_pls_mod$paths
loadings_mod     <- sum_pls_mod$loadings
cross_loadings_mod <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights_mod      <- sum_pls_mod$weights
rSquared_mod     <- sum_pls_mod$rSquared
reliability_mod  <- sum_pls_mod$reliability
htmt_mod         <- sum_pls_mod$htmt
fSquare_mod      <- sum_pls_mod$fSquare
collinearity_mod <- sum_pls_mod$validity$vif_items
collinearity2_mod  <- sum_pls_mod$vif_antecedents
fornell_larcker_mod <-  sum_pls_mod$validity$fl_criteria
items_statistics_mod <- sum_pls_mod$descriptives$statistics$items

# Write each to CSV
write.csv(total_effects_mod ,  "total_effects_mod .csv", row.names = TRUE)
write.csv(total_indirect_effects_mod , "total_indirect_effects_mod .csv", row.names = TRUE)
write.csv(paths_mod,       "paths_mod.csv", row.names = FALSE)
write.csv(loadings_mod,    "loadings_mod.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings_mod.csv", row.names = TRUE)
write.csv(weights_mod,     "weights_mod.csv", row.names = TRUE)
write.csv(rSquared_mod,    "rSquared_mod.csv", row.names = TRUE)
write.csv(reliability_mod, "reliability_mod.csv", row.names = TRUE)
write.csv(htmt_mod,        "htmt_mod.csv", row.names = TRUE)
write.csv(fSquare_mod,     "fSquare_mod.csv", row.names = TRUE)
write.csv(collinearity_mod, "collinearity_mod.csv", row.names = TRUE)
write.csv(collinearity2_mod, "collinearity2_mod.csv", row.names = TRUE)
write.csv(fornell_larcker_mod,"fornell_larcker_mod.csv", row.names = TRUE)
write.csv(items_statistics_mod,"items_statistics_mod.csv", row.names = TRUE)


## Summarize the PLS-SEM model outputs and take them to a single Excel file

### Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)


wb <- createWorkbook()
addWorksheet(wb, "total_effects_mod "); writeData(wb, "total_effects_mod ", sum_pls_mod$total_effects, headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects_mod "); writeData(wb, "total_indirect_effects_mod ", sum_pls_mod$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths_mod");        writeData(wb, "Paths_mod", sum_pls_mod$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings_mod");     writeData(wb, "Loadings_mod", sum_pls_mod$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings_mod");     writeData(wb, "cross_loadings_mod", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle 																	= 															header_style, borders = "all")
addWorksheet(wb, "Weights_mod");      writeData(wb, "Weights_mod", sum_pls_mod$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared_mod");     writeData(wb, "RSquared_mod", sum_pls_mod$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability_mod");  writeData(wb, "Reliability_mod", sum_pls_mod$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT_mod");         writeData(wb, "HTMT_mod", sum_pls_mod$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare_mod");      writeData(wb, "fSquare_mod", sum_pls_mod$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity_mod");  writeData(wb, "collinearity_mod", sum_pls_mod$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2_mod"); writeData(wb, "collinearity2_mod", sum_pls_mod$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker_mod"); writeData(wb, "fornell_larcker_mod", sum_pls_mod$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics_mod"); writeData(wb, "items_statistics_mod", sum_pls_mod$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")

saveWorkbook(wb, "Promise Objective mod.xlsx", overwrite = TRUE)


####################### FORMATTED VERSION WITH FUNCTION ##########################################################################

# --- Create workbook ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}

# --- PLS model results ---
addWorksheet(wb, "total_effects_mod"); writeData(wb, "total_effects_mod", sum_pls_mod$total_effects , headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects_mod"); writeData(wb, "total_indirect_effects_mod ", sum_pls_mod$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths_mod");        writeData(wb, "Paths_mod", sum_pls_mod$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings_mod");     writeData(wb, "Loadings_mod", sum_pls_mod$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings_mod");     writeData(wb, "cross_loadings_mod", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle 																	= 															header_style, borders = "all")
addWorksheet(wb, "Weights_mod");      writeData(wb, "Weights_mod", sum_pls_mod$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared_mod");     writeData(wb, "RSquared_mod", sum_pls_mod$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability_mod");  writeData(wb, "Reliability_mod", sum_pls_mod$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT_mod");         writeData(wb, "HTMT_mod", sum_pls_mod$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare_mod");      writeData(wb, "fSquare_mod", sum_pls_mod$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity_mod");  writeData(wb, "collinearity_mod", sum_pls_mod$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2_mod"); writeData(wb, "collinearity2_mod", sum_pls_mod$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker_mod"); writeData(wb, "fornell_larcker_mod", sum_pls_mod$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics_mod"); writeData(wb, "items_statistics_mod", sum_pls_mod$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")


# ---  Save workbook ---
saveWorkbook(wb, "Promise Objective mod.xlsx", overwrite = TRUE)

message("✅ Export complete: PLS results written to Promise Objective 1.xlsx")



  ### Bootstrapping the results
  boot_pls_mod <- bootstrap_model(seminr_model = pl_sm_mod,
                                  nboot = 1000,
                                  cores = NULL,
                                  seed = 123)
  
  ## Summarize the results of the bootstrap
  sum_boot_pls_mod <- summary(boot_pls_mod, alpha = 0.05)
 
  #### Obtain results on model estimates such as the path coefficients with sum_boot_pls_mod$bootstrapped_paths.
  ######## Get the P-value and save the bootstrapping result to csv #################################
 
sum_boot_paths_mod <- sum_boot_pls_mod$bootstrapped_paths

 ### Check the class of  sum_boot_paths

class(sum_boot_paths_mod)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths_mod)

# Now create a column for the rownames 
sum_boot_paths_mod$Path <- rownames(sum_boot_paths_mod)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths_mod) <- NULL

# Make Path the first column
sum_boot_paths_mod  <- sum_boot_paths_mod[, c("Path", setdiff(names(sum_boot_paths_mod), "Path"))]


# Convert bootstrap results to data.frame 
  sum_boot_paths_mod <- as.data.frame(sum_boot_paths_mod)
  sum_boot_paths_mod # Print to see the content


 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once

sum_boot_paths_mod <- as.data.frame(sum_boot_paths_mod) %>% 
  rownames_to_column(var = "Path")


  # Compute p-values (using "T Stat." column with dot)
  sum_boot_paths_mod$p_value <- round(2 * (1 - pnorm(abs(sum_boot_paths_mod[,"T Stat."]))),4)
  
  colnames(sum_boot_paths_mod)
  head(sum_boot_paths_mod)
  
  # Add significance levels
  sum_boot_paths_mod$Significance <- cut(
    sum_boot_paths_mod$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  
  # Create a clean table with selected columns
  clean_results_mod <- sum_boot_paths_mod[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                        "2.5% CI","97.5% CI", "p_value" ,      
                                        "Significance" )]
  
  # Rename columns for clarity
  colnames(sum_boot_paths_mod) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                 "2.5% CI","97.5% CI", "p_value" ,      
                                 "Significance" )
  
  
  # Export to CSV (saves in working directory)
  write.csv(
    clean_results_mod,
    file = "path_bootstrap_results_mod.csv",
    row.names = TRUE)
  )
  
  # Confirm location
  cat("✅ Clean results with CIs saved as 'path_bootstrap_results_mod.csv' in your working directory\n")
  
  
  
  ###### Writing the bootstrapping as a function (optional) 
  
  export_bootstrap_results <- function(pathbootstrap_mod, filename = "bootstrap_results_mod.csv") {
    
 sum_boot_paths_mod <- sum_boot_pls_mod$bootstrapped_paths

 ### Check the class of  sum_boot_paths

class(sum_boot_paths_mod)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths_mod)

# Now create a column for the rownames 
sum_boot_paths_mod$Path <- rownames(sum_boot_paths_mod)


### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths) <- NULL

# Make Path the first column
sum_boot_paths_mod  <- sum_boot_paths_mod[, c("Path", setdiff(names(sum_boot_paths_mod), "Path"))]



# Convert bootstrap results to data.frame 
  sum_boot_paths_mod <- as.data.frame(sum_boot_paths_mod)
  sum_boot_paths_mod # Print to see the content


    
    # Compute p-values (using "T Stat." column with dot)
    sum_boot_paths_mod$p_value <- 2 * (1 - pnorm(abs(sum_boot_paths_mod[,"T Stat."])))
    
    # Add significance levels
    sum_boot_paths_mod$Significance <- cut(
      sum_boot_paths_mod$p_value,
      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
      labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
    )
    
    # Create a clean table with selected columns
    clean_results_mod <- sum_boot_paths_mod[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                         "2.5% CI","97.5% CI", "p_value" ,      
                                         "Significance" )]
    
    # Rename columns for clarity
    colnames(clean_results_mod) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                   "2.5% CI","97.5% CI", "p_value" ,      
                                   "Significance" )
    
    # Export to CSV
    
    write.csv(
      clean_results_mod,
      file = "path_bootstrap_results_mod.csv",
      row.names = TRUE
    )
    
    # Confirm location
    cat("✅ Clean results with CIs saved as 'bootstrap_results_mod.csv' in your working directory\n")
    
    
  }
  
  export_bootstrap_results(pathbootstrap_mod)


  
  #### Bootstrapping of outer loadings 
  ####### Get the P-value and save the bootstrapping result to csv #################################
   
sum_boot_loadings_mod  <- sum_boot_pls_mod$bootstrapped_loadings

 ### Check the class of  sum_boot_paths

class(sum_boot_loadings_mod)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_loadings_mod)

# Now create a column for the rownames 
sum_boot_paths_mod$Path <- rownames(sum_boot_loadings_mod)


### Set the rownames to null, so it is no more appearing
rownames(sum_boot_loadings_mod) <- NULL

# Make Loadings the first column 
sum_boot_loadings <- sum_boot_loadings [, c("Loadings", setdiff(names(sum_boot_loadings_mod), "Loadings"))]



# Convert bootstrap results to data.frame 
  sum_boot_loadings_mod <- as.data.frame(sum_boot_loadings_mod)
  sum_boot_loadings_mod  # Print to see the content


 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once
sum_boot_loadings_mod <- as.data.frame(sum_boot_loadings_mod) %>%  
  rownames_to_column(var = "Loadings") # Won’t be used inside the function version at the same time as the above 



  # Compute p-values (using "T Stat." column with dot)
   sum_boot_loadings_mod$p_value <- round(2 * (1 - pnorm(abs( sum_boot_pls_mod_loadings[,"T Stat."]))),4)
  
  ### Get the column headers
  colnames(sum_boot_loadings_mod)
  head(sum_boot_loadings_mod)
  
  # Add significance levels
   sum_boot_loadings_mod$Significance <- cut(
     sum_boot_loadings_mod$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  
  # Create a clean table with selected columns
  clean_results_loadings_mod <- sum_boot_loadings_mod[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                      "2.5% CI","97.5% CI", "p_value" ,      
                                      "Significance" )]
  
  # Rename columns for clarity
  colnames(clean_results_loadings_mod) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                "2.5% CI","97.5% CI", "p_value" ,      
                                "Significance" )
    
  
  # Export to CSV (saves in working directory)
  write.csv(
    clean_results_loadings_mod,
    file = "loadings_boostrap_mod.csv",
    row.names = TRUE
  )
  
  # Confirm location
  cat("✅ Clean results of loadings with CIs saved as 'outer_loadings_boostrap_mod.csv' in your working directory\n")
 

# Saving the bootstrapping results to file

## Summarize the PLS-SEM Bootstrapping outputs and take them to their respective CSV files

sum_boot_pls_mod <- summary(boot_model, , alpha = 0.05) 

### Extract key components
 sum_boot_paths_mod <- sum_boot_paths_mod # No need to run the sum_boot_paths_mod$bootstrapped_paths again, since one containing the p-value and  	#significance is available above

 sum_boot_loadings_mod <-  sum_boot_loadings_mod # No need to run the sum_boot_loadings_mod$bootstrapped_loadings again, since one containing the p-value and     #significance is available above

sum_boot_weights_mod  <- sum_boot_pls_mod$bootstrapped_weights
sum_boot_HTMT_mod     <- sum_boot_pls_mod$bootstrapped_HTMT


### Write each to CSV
write.csv(sum_boot_paths_mod,  "boot_paths_mod.csv", row.names = TRUE)
write.csv(sum_boot_loadings_mod,  "boot_loadings_mod.csv", row.names = TRUE)
write.csv(sum_boot_weights_mod,  "boot_weights_mod.csv", row.names = TRUE)
write.csv(sum_boot_HTMT_mod,  "boot_HTMT_mod.csv", row.names = TRUE)


## Summarize the PLS-SEM Bootstrapping model outputs and take them to a single Excel file
wb <- createWorkbook()
add_sheet(wb, "sum_boot_paths_mod",     sum_boot_paths_mod)  #We need not run sum_boot_pls_mod$bootstrapped_paths again
add_sheet(wb, "sum_boot_loadings_mod",  sum_boot_loadings_mod) # We need not run sum_boot_pls_mod$bootstrapped_loadings again
add_sheet(wb, "sum_boot_weights_mod",   sum_boot_pls_mod$bootstrapped_weights_mod)
add_sheet(wb, "sum_boot_HTMT_mod",      sum_boot_pls_mod$bootstrapped_HTMT_mod)

saveWorkbook(wb, " Promise PLS_SEM_with_BootstrapMod.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


# Summarize the PLS-SEM bootsrap ouputs and take them to their respective CSV files


# Extract key components
sum_boot_paths_mod <- sum_boot_paths_mod
sum_boot_loadings_mod <-  sum_boot_loadings_mod
sum_boot_weights_mod  <- sum_boot_pls_mod$bootstrapped_weights
sum_boot_HTMT_mod     <- sum_boot_pls_mod$bootstrapped_HTMT


# Write each to CSV
write.csv(sum_boot_paths_mod,  "boot_paths_mod.csv", row.names = TRUE)
write.csv(sum_boot_loadings_mod,  "boot_loadings_mod.csv", row.names = TRUE)
write.csv(sum_boot_weights_md,  "boot_weights_mod.csv", row.names = TRUE)
write.csv(sum_boot_HTMT_mod,  "boot_HTMT_mod.csv", row.names = TRUE)



# Summarize the PLS-SEM bootstrapping outputs and take them to a single Excel file

# Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

wb <- createWorkbook()

# --- Bootstrap results ---
add_sheet(wb, "sum_boot_paths_mod",     sum_boot_paths_mod ,headerStyle = header_style, borders = "all") # We need not run #sum_boot_pls_					#$bootstrapped_paths again

add_sheet(wb, "sum_boot_loadings_mod",  sum_boot_loadings_mod, headerStyle = header_style, borders = "all")  # We need not run #sum_boot_pls_mod$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights_mod",   sum_boot_pls_mod$bootstrapped_weights, headerStyle = header_style, borders = "all")
add_sheet(wb, "sum_boot_HTMT_mod",      sum_boot_pls_mod$bootstrapped_HTMT, headerStyle = header_style, borders = "all")
saveWorkbook(wb, " Promise PLS_SEM_with_BootstrapMod.xlsx ", overwrite = TRUE)



####################### FORMATTED VERSION WITH FUNCTION - BOOTSTRAPPING ######################################

# --- Create workbook for bootstrapping ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4F81BD",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}


# --- Bootstrap results ---
add_sheet(wb, "sum_boot_paths_mod",     sum_boot_paths_mod) # We need not run #sum_boot_pls_mod$bootstrapped_paths again

add_sheet(wb, "sum_boot_loadings_mod",  sum_boot_loadings_mod) # We need not run #sum_boot_pls_mod$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights_mod",   sum_boot_pls_mod$bootstrapped_weights)
add_sheet(wb, "sum_boot_HTMT_mod",      sum_boot_pls_mod$bootstrapped_HTMT)

# --- Save workbook ---
saveWorkbook(wb, "Promise PLS_SEM_with_BootstrapMod.xlsx", overwrite = TRUE)

message("✅ Export complete: Bootstrap results written to Promise PLS_SEM_with_BootstrapMod.xlsx")


#To better comprehend the results of the moderator analysis, we use the slope_analysis() function to visualize the two-way interaction effect. 

  slope_analysis(
    moderated_model = pl_sm_mod, 
    dv = "OP",
    moderator = "FL",
    iv = "MAT",
    leg_place = "bottomright")
  

  # Create the Visualization
  
 plot(pl_sm_mod,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()


# The bootstrapped model can also be visualized

 plot(boot_pls_mod,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()


# To save plot, we can also use:
# save_plot("plotname.png")


### Use of Lavaan package for analysis

  # Step 1: Specify the measurement + main effects model
  model_main <- '
  # Measurement
  MAT =~ MAT1 + MAT2 + MAT3 + MAT4 + MAT5
  FL  =~ FL1 + FL2 + FL3 + FL4
  OP  =~ OP1 + OP2 + OP3 + OP4 + OP5

  # Structural (main effects only)
  OP ~ MAT + FL
'
  
  fit_main <- sem(model_main, data = data)
  
  # Step 2: Save factor scores to build interaction term
  fscores <- lavPredict(fit_main)   # gives factor scores for MAT, FL, OP
  data$MATxFL <- fscores[,"MAT"] * fscores[,"FL"]
  
  model_mod <- '
  # Measurement
  MAT =~ MAT1 + MAT2 + MAT3 + MAT4 + MAT5
  FL  =~ FL1 + FL2 + FL3 + FL4
  OP  =~ OP1 + OP2 + OP3 + OP4 + OP5

  # Structural with moderation
  OP ~ MAT + FL + MATxFL
'
  
  fit_mod <- sem(model_mod, data = dt)
  
  # Step 3. Plot
  semPaths(fit_mod, "std", whatLabels = "std", edge.label.cex = 1.2)
  
  
  
  ## 9. Use semPlot's semPaths function for visualization
  semPaths(
    object       = fit_mod,    # seminr model
    what         = "path",       # show path model
    whatLabels   = "est",        # show estimates
    style        = "lisrel",     # clean LISREL-style layout
    edge.label.cex = 1.0,        # font size for path coefficients
    sizeMan      = 6,            # indicator box size
    sizeLat      = 8,            # latent variable size
    residuals    = FALSE,        # hide residual arrows
    intercepts   = FALSE,        # hide intercepts
    layout       = "tree",       # top-down or left-right tree layout
    color        = list(lat = "blue", man = "yellow"), # node colors
    nCharNodes   = 0,            # don't shorten names
    asize        = 2,            # arrow thickness
    edge.color   = "black"       # arrow color
  )
  
  
  ## 10. Save the plot as PNG
  png("pls_path_model_publication_ready2.png", width = 1600, height = 1000, res = 150)
  semPaths(
    object       = fit_mod,
    what         = "path",
    whatLabels   = "est",
    -   style        = "lisrel",
    edge.label.cex = 1.2,
    sizeMan      = 6,
    sizeLat      = 8,
    residuals    = FALSE,
    intercepts   = FALSE,
    layout       = "tree",
    color        = list(lat = "blue", man = "yellow"),
    nCharNodes   = 0,
    asize        = 2,
    edge.color   = "black"
  )
  dev.off()
  
  


  ###################### Objective 3 ##################################################
    
    
    ## 3. Define measurement model
  mm <- constructs(
    composite("MAT", multi_items("MAT", 1:5), weights = mode_A),
    composite("ITR",  multi_items("ITR", 1:5), weights = mode_A)
    
  )
  
  
  ## 4. Structural model
  sm <- relationships(
    paths(from = "MAT", to = "ITR"))
    
    ## 5. Estimate model
    pls_model <- estimate_pls(data = dt, measurement_model = mm, structural_model = sm,inner_weights = path_weighting,
    missing = mean_replacement,
     missing_value = "-99")

    summary(pls_model)
    



### 6. Summarizing the model
  # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.
  summary_pls_model <- summary(pls_model)
  

  #### calling summary_pls_model$total_effects, we inspect the model's total effects
   summary_pls_model$total_effects

  #### calling summary_pls_model$total_indirect_effects, we inspect the model's total indirect effects
   summary_pls_model$total_indirect_effects

  #### calling summary_pls_model$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
  summary_pls_model$paths
  
  #### calling summary_pls_model$reliability, we inspect the construct reliability metrics
  summary_pls_model$reliability
  
  
  #### we can plot the reliability
  plot(summary_pls_model$reliability)
  
  if(requireNamespace("car", quietly = TRUE)) {
    library(car)
    # Note: seminr does not directly give VIF; can compute VIF using construct scores
    lm1 <- lm(OP ~ MAT , data = dt)
    vif_vals <- car::vif(lm1)
    print(vif_vals)
    write_csv(as.data.frame(vif_vals), "pls_vif_innermodel.csv")
  }


 #### calling summary_pls_model$validity, we inspect the construct validity metrics # Check this out first to see contents
  summary_pls_model$validity

  #### calling summary_pls_model$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
  summary_pls_model$validity$fl_criteria
  
  #### Calling summary_pls_model$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
  summary_pls_model$validity$htmt
  
  
  ### Calling summary_pls_model$vif_antecedents, we inspect the VIF for collinearity
  summary_pls_model$vif_antecedents
  
  ### To get VIF # Option 2 - Compare with the first one above
  summary_pls_model$validity$vif_items
  

  #### We can access summary statistics of the model’s items
  items_statistics_summary_pls_model<- summary_pls_model$descriptives$statistics$items
  items_statistics_summary_pls_model
 
  
  #### To get the construct statistics.
  constructs_statistics_summary_pls_model <-  summary_pls_model$descriptives$statistics$constructs
  constructs_statistics_summary_pls_model
  
  ##. Outer loadings (indicator reliability)
  pls_model$outer_loadings
  
   ## Or
  outer_loadings_pls_model <- summary_pls_model$loadings
  print(outer_loadings_pls_model)
  
   
   ##. weights
   pls_model$outer_weights
   
   # Or
   weights_pls_model <- summary_pls_model$weights
   print(weights_pls_model)
   
   # Compute cross-loadings manually. Cross-loading is a correlation between the data itself and the construct score
   cross_loadings_pls_model <- cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs")
   
   # Round for neatness
   round(cross_loadings_pls_model, 4)
   
   
   # To get the effect size
   fsquare_pls_model  <- summary_pls_model$fSquare
   fsquare_pls_model
   
  ##. Construct scores (latent variable scores)
  construct_scores1 <- pls_model$scores # Option 1 - Check this out again
  construct_scores1
  
 construct_scores2 <-  pls_model$construct_scores # Option 2 
 construct_scores2

 construct_scores3 <-  summary_pls_model$composite_scores # Option 3  - Check this out again
 construct_scores3



# Saving the PL-SEM results to file

## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
summary_pls_model <- summary(pls_model)

# Extract key components
total_effects <- summary_pls_model$total_effects
total_indirect_effects <- summary_pls_model$total_indirect_effects
paths        <- summary_pls_model$paths
loadings     <- summary_pls_model$loadings
cross_loadings <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights      <- summary_pls_model$weights
rSquared     <- summary_pls_model$rSquared
reliability  <- summary_pls_model$reliability
htmt         <- summary_pls_model$htmt
fSquare      <- summary_pls_model$fSquare
collinearity <- summary_pls_model$validity$vif_items
collinearity2<- summary_pls_model$vif_antecedents
fornell_larcker <-  summary_pls_model$validity$fl_criteria
items_statistics <- summary_pls_model$descriptives$statistics$items

### Write each to CSV
write.csv(total_effects,  "total_effects.csv", row.names = TRUE)
write.csv(total_indirect_effects, "total_indirect_effects.csv", row.names = TRUE)
write.csv(paths,       "paths.csv", row.names = TRUE)
write.csv(loadings,    "loadings.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings.csv", row.names = TRUE)
write.csv(weights,     "weights.csv", row.names = TRUE)
write.csv(rSquared,    "rSquared.csv", row.names = TRUE)
write.csv(reliability, "reliability.csv", row.names = TRUE)
write.csv(htmt,        "htmt.csv", row.names = TRUE)
write.csv(fSquare,     "fSquare.csv", row.names = TRUE)
write.csv(collinearity, "collinearity.csv", row.names = TRUE)
write.csv(collinearity2, "collinearity2.csv", row.names = TRUE)
write.csv(fornell_larcker,"fornell_larcker.csv", row.names = TRUE)
write.csv(items_statistics,"items_statistics.csv", row.names = TRUE)



## Summarize the PLS-SEM model outputs and take them to a single Excel file

wb <- createWorkbook()
addWorksheet(wb, "total_effects"); writeData(wb, "total_effects", summary_pls_model$total_effects)
addWorksheet(wb, "total_indirect_effects"); writeData(wb, "total_indirect_effects", summary_pls_model$total_indirect_effects)
addWorksheet(wb, "Paths");        writeData(wb, "Paths", summary_pls_model$paths)
addWorksheet(wb, "Loadings");     writeData(wb, "Loadings", summary_pls_model$loadings)
addWorksheet(wb, "cross_loadings");     writeData(wb, "cross_loadings", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4))
addWorksheet(wb, "Weights");      writeData(wb, "Weights", summary_pls_model$weights)
addWorksheet(wb, "RSquared");     writeData(wb, "RSquared", summary_pls_model$rSquared)
addWorksheet(wb, "Reliability");  writeData(wb, "Reliability", summary_pls_model$reliability)
addWorksheet(wb, "HTMT");         writeData(wb, "HTMT", summary_pls_model$htmt)
addWorksheet(wb, "fSquare");      writeData(wb, "fSquare", summary_pls_model$fSquare)
addWorksheet(wb, "collinearity");  writeData(wb, "collinearity", summary_pls_model$validity$vif_items)
addWorksheet(wb, "collinearity2"); writeData(wb, "collinearity2", summary_pls_model$vif_antecedents)
addWorksheet(wb, "fornell_larcker"); writeData(wb, "fornell_larcker", summary_pls_model$validity$fl_criteria)
addWorksheet(wb, "items_statistics"); writeData(wb, "items_statistics", summary_pls_model$descriptives$statistics$items)

saveWorkbook(wb, "Promise Objective 3.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
summary_pls_model <- summary(pls_model)

# Extract key components
total_effects <- summary_pls_model$total_effects
total_indirect_effects <- summary_pls_model$total_indirect_effects
paths        <- summary_pls_model$paths
loadings     <- summary_pls_model$loadings
cross_loadings <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights      <- summary_pls_model$weights
rSquared     <- summary_pls_model$rSquared
reliability  <- summary_pls_model$reliability
htmt         <- summary_pls_model$htmt
fSquare      <- summary_pls_model$fSquare
collinearity <- summary_pls_model$validity$vif_items
collinearity2<- summary_pls_model$vif_antecedents
fornell_larcker <-  summary_pls_model$validity$fl_criteria
items_statistics <- summary_pls_model$descriptives$statistics$items

# Write each to CSV
write.csv(total_effects,  "total_effects.csv", row.names = TRUE)
write.csv(total_indirect_effects, "total_indirect_effects.csv", row.names = TRUE)
write.csv(paths,       "paths.csv", row.names = TRUE)
write.csv(loadings,    "loadings.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings.csv", row.names = TRUE)
write.csv(weights,     "weights.csv", row.names = TRUE)
write.csv(rSquared,    "rSquared.csv",row.names = TRUE)
write.csv(reliability, "reliability.csv", row.names = TRUE)
write.csv(htmt,        "htmt.csv", row.names = TRUE)
write.csv(fSquare,     "fSquare.csv", row.names = TRUE)
write.csv(collinearity, "collinearity.csv", row.names = TRUE)
write.csv(collinearity2, "collinearity2.csv", row.names = TRUE)
write.csv(fornell_larcker,"fornell_larcker.csv", row.names = TRUE)
write.csv(items_statistics,"items_statistics.csv", row.names = TRUE)



## Summarize the PLS-SEM model outputs and take them to a single Excel file

### Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)


wb <- createWorkbook()
addWorksheet(wb, "total_effects"); writeData(wb, "total_effects", summary_pls_model$total_effects, headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects"); writeData(wb, "total_indirect_effects", summary_pls_model$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths");        writeData(wb, "Paths", summary_pls_model$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings");     writeData(wb, "Loadings", summary_pls_model$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings");     writeData(wb, "cross_loadings", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle = 															header_style, borders = "all")
addWorksheet(wb, "Weights");      writeData(wb, "Weights", summary_pls_model$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared");     writeData(wb, "RSquared", summary_pls_model$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability");  writeData(wb, "Reliability", summary_pls_model$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT");         writeData(wb, "HTMT", summary_pls_model$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare");      writeData(wb, "fSquare", summary_pls_model$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity");  writeData(wb, "collinearity", summary_pls_model$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2"); writeData(wb, "collinearity2", summary_pls_model$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker"); writeData(wb, "fornell_larcker", summary_pls_model$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics"); writeData(wb, "items_statistics", summary_pls_model$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")

saveWorkbook(wb, "Promise Objective 3.xlsx", overwrite = TRUE)


####################### FORMATTED VERSION WITH FUNCTION ##########################################################################

# --- Create workbook ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}

# --- PLS model results ---
addWorksheet(wb, "total_effects"); writeData(wb, "total_effects", summary_pls_model$total_effects, headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects"); writeData(wb, "total_indirect_effects", summary_pls_model$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths");        writeData(wb, "Paths", summary_pls_model$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings");     writeData(wb, "Loadings", summary_pls_model$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings");     writeData(wb, "cross_loadings", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle = 															header_style, borders = "all")
addWorksheet(wb, "Weights");      writeData(wb, "Weights", summary_pls_model$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared");     writeData(wb, "RSquared", summary_pls_model$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability");  writeData(wb, "Reliability", summary_pls_model$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT");         writeData(wb, "HTMT", summary_pls_model$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare");      writeData(wb, "fSquare", summary_pls_model$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity");  writeData(wb, "collinearity", summary_pls_model$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2"); writeData(wb, "collinearity2", summary_pls_model$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker"); writeData(wb, "fornell_larcker", summary_pls_model$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics"); writeData(wb, "items_statistics", summary_pls_model$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")


# ---  Save workbook ---
saveWorkbook(wb, "Promise Objective 3.xlsx", overwrite = TRUE)

message("✅ Export complete: PLS results written to Promise Objective 3.xlsx")




  # Bootstrapping the results

  boot_model <- bootstrap_model(seminr_model = pls_model,
                                nboot = 1000,
                                cores = NULL,
                                seed = 123)
  
  sum_boot_model <- summary(boot_model, , alpha = 0.05)
  
  #### Obtain bootstrapping results on model estimates such as the path coefficients with sum_boot_model$bootstrapped_paths.

  ######## Get the P-value and save the bootstrapping result to csv #################################
  
 sum_boot_paths <- sum_boot_model$bootstrapped_paths

 ### Check the class of  sum_boot_paths

class(sum_boot_paths)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_paths)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths) <- NULL

# Make Path the first column
sum_boot_paths  <- sum_boot_paths [, c("Path", setdiff(names(sum_boot_paths), "Path"))]


# Convert bootstrap results to data.frame 
  sum_boot_paths <- as.data.frame(sum_boot_paths)
  sum_boot_paths # Print to see the content

  
 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once

sum_boot_paths <- as.data.frame(sum_boot_paths) %>% 
  rownames_to_column(var = "Path")



  # Compute p-values (using "T Stat." column with dot)
  sum_boot_paths$p_value <- round(2 * (1 - pnorm(abs(sum_boot_paths[,"T Stat."]))),4)
  
  ### Get the column headers
  colnames(sum_boot_paths)
  head(sum_boot_paths)
  
  # Add significance levels
  sum_boot_paths$Significance <- cut(
    sum_boot_paths$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  

  # Create a clean table with selected columns
  paths_clean_results <- sum_boot_paths[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                      "2.5% CI","97.5% CI", "p_value" ,      
                                      "Significance" )]
  
  # Rename columns for clarity
  colnames(paths_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                "2.5% CI","97.5% CI", "p_value" ,      
                                "Significance" )
    
  
  # Export to CSV (saves in working directory)
  write.csv(
    paths_clean_results,
    file = "paths_bootstrap_results3.csv",
    row.names = TRUE
  )
  
  # Confirm location
  cat("✅ Clean results with CIs saved as 'bootstrap_results.csv' in your working directory\n")
  
  
  
  ###### Writing the path bootstrapping as a function (optional)
  
  export_path_bootstrap_results <- function(pathbootstrap, filename = "path_bootstrap_results.csv") {
    sum_boot_paths <- sum_boot_model$bootstrapped_paths

 ### Check the class of  sum_boot_paths

class( sum_boot_paths)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_paths)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths) <- NULL

# Make Path the first column
sum_boot_paths  <- sum_boot_paths [, c("Path", setdiff(names(sum_boot_paths), "Path"))]



# Convert bootstrap results to data.frame 
  sum_boot_paths <- as.data.frame(sum_boot_paths)
  sum_boot_paths # Print to see the content
    
    # Compute p-values (using "T Stat." column with dot)
    sum_boot_paths$p_value <- 2 * (1 - pnorm(abs(sum_boot_paths[,"T Stat."])))
    
    # Add significance levels

    sum_boot_paths$Significance <- cut(
      sum_boot_paths$p_value,
      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
      labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
    )
    
    # Create a clean table with selected columns
    paths_clean_results <- sum_boot_paths[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                        "2.5% CI","97.5% CI", "p_value" ,      
                                        "Significance" )]
    
    # Rename columns for clarity
    colnames(paths_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                  "2.5% CI","97.5% CI", "p_value" ,      
                                  "Significance" )
    
    # Export to CSV
    write.csv(
      paths_clean_results,
      file = "paths_bootstrap_results3.csv",
      row.names = TRUE
    )
    
    # Confirm location
    cat("✅ Clean results with CIs saved as 'path_bootstrap_results.csv' in your working directory\n")
    
  cat("✅ Path bootstrap results exported \n")
  }
  
  export_path_bootstrap_results(pathbootstrap)
  
  
  #### Bootstrapping of outer loadings 

  ####### Get the P-value and save the bootstrapping result to csv #################################
 

 sum_boot_loadings  <- sum_boot_model$bootstrapped_loadings

 ### Check the class of  sum_boot_loadings

class(sum_boot_loadings)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_loadings)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_loadings)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_loadings) <- NULL

# Make Loadings the first column 
sum_boot_loadings <- sum_boot_loadings [, c("Loadings", setdiff(names(sum_boot_loadings), "Loadings"))]

# Convert bootstrap results to data.frame 
  sum_boot_loadings <- as.data.frame(sum_boot_loadings)
  sum_boot_loadings  # Print to see the content

  
 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once
sum_boot_loadings<- as.data.frame(sum_boot_loadings) %>%  
  rownames_to_column(var = "Loadings") # Won’t be used inside the function version at the same time as the above 



  # Compute p-values (using "T Stat." column with dot)
  sum_boot_loadings$p_value <- round(2 * (1 - pnorm(abs(sum_boot_loadings[,"T Stat."]))),4)
  
  ### Get the column headers
  colnames(sum_boot_loadings)
  head(sum_boot_loadings)
  
  # Add significance levels
  sum_boot_loadings$Significance <- cut(
    sum_boot_loadings$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  
  # Create a clean table with selected columns
  loadings_clean_results <- sum_boot_loadings[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                      "2.5% CI","97.5% CI", "p_value" ,      
                                      "Significance" )]
  
  # Rename columns for clarity
  colnames(loadings_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                "2.5% CI","97.5% CI", "p_value" ,      
                                "Significance" )
    
  
  # Export to CSV (saves in working directory)
  write.csv(
    loadings_clean_results,
    file = "loadings_boostrap_result3.csv",
    row.names = TRUE
  )
  
  # Confirm location
  cat("✅ Clean results of loadings with CIs saved as 'outer_loadings_boostrap.csv' in your working directory\n")
 


###### Writing the loadings bootstrapping as a function (optional)


  
  export_loadings_bootstrap_results <- function(loadingsbootstrap, filename = "loadings_bootstrap_results.csv") {
    sum_boot_loadings <- sum_boot_model$bootstrapped_loadings

 ### Check the class of  sum_boot_loadings

class( sum_boot_loadings)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_loadings)

# Now create a column for the rownames 
sum_boot_paths$Loadings <- rownames(sum_boot_loadings)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_loadings) <- NULL

# Make Path the first column
sum_boot_loadings  <- sum_boot_loadings[, c("Loadings", setdiff(names(sum_boot_loadings), "Loadings"))]



# Convert bootstrap results to data.frame 
  sum_boot_loadings <- as.data.frame(sum_boot_loadings)
  sum_boot_loadings # Print to see the content
    
    # Compute p-values (using "T Stat." column with dot)
    sum_boot_loadings$p_value <- 2 * (1 - pnorm(abs(sum_boot_loadings[,"T Stat."])))
    
    # Add significance levels

    sum_boot_loadings$Significance <- cut(
      sum_boot_loadings$p_value,
      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
      labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
    )
    
    # Create a clean table with selected columns
    loadings_clean_results <- sum_boot_loadings[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                        "2.5% CI","97.5% CI", "p_value" ,      
                                        "Significance" )]
    
    # Rename columns for clarity
    colnames(loadings_clean_results) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                  "2.5% CI","97.5% CI", "p_value" ,      
                                  "Significance" )
    
    # Export to CSV
    write.csv(
      loadings_clean_results,
      file = "loadings_bootstrap_results3.csv",
      row.names = TRUE
    )
    
    # Confirm location
    cat("✅ Clean results with CIs saved as 'loadings_bootstrap_results.csv' in your working directory\n")
    
  cat("✅ Loadings bootstrap results exported \n")
  }
  
  export_loadings_bootstrap_results(loadingsbootstrap)
  



# Saving the bootstrapping results to file

## Summarize the PLS-SEM Bootstrapping outputs and take them to their respective CSV files

### Extract key components
sum_boot_paths <- sum_boot_paths # No need to run the sum_boot_model$sum_boot_paths again, # since one containing the p-value and significance is available above

sum_boot_loadings <-  sum_boot_loadings # No need to run the sum_boot_model$sum_boot_loadings again, since one containing the p-value and     	#significance is available above

sum_boot_weights  <- sum_boot_model$bootstrapped_weights
sum_boot_HTMT     <- sum_boot_model$bootstrapped_HTMT


### Write each to CSV
write.csv(sum_boot_paths,  "boot_paths3.csv", row.names = TRUE)
write.csv(sum_boot_loadings,  "boot_loadings3.csv", row.names = TRUE)
write.csv(sum_boot_weights,  "boot_weights3.csv", row.names = TRUE)
write.csv(sum_boot_HTMT,  "boot_HTMT3.csv", row.names = TRUE)


## Summarize the PLS-SEM Bootstrapping model outputs and take them to a single Excel file
wb <- createWorkbook()
add_sheet(wb, "sum_boot_paths",     sum_boot_paths)  # We need not run sum_boot_model$bootstrapped_paths again. Available above
add_sheet(wb, "sum_boot_loadings",  sum_boot_loadings) # We need not run sum_boot_model$bootstrapped_loadings again. Available above
add_sheet(wb, "sum_boot_weights",   sum_boot_model$bootstrapped_weights)
add_sheet(wb, "sum_boot_HTMT",      sum_boot_model$bootstrapped_HTMT)

saveWorkbook(wb, "Promise Obj 3_Bootstrap.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


# Summarize the PLS-SEM bootstrap outputs and take them to their respective CSV files


# Extract key components
sum_boot_paths <- sum_boot_paths # We need not run sum_boot_model$bootstrapped_paths again. Available above
sum_boot_loadings <-  sum_boot_loadings # We need not run sum_boot_model$bootstrapped_loadings again. Available above
sum_boot_weights  <- sum_boot_model$bootstrapped_weights
sum_boot_HTMT     <- sum_boot_model$bootstrapped_HTMT


# Write each to CSV
write.csv(sum_boot_paths,  "boot_paths.csv", row.names = TRUE)
write.csv(sum_boot_loadings,  "boot_loadings.csv", row.names = TRUE)
write.csv(sum_boot_weights,  "boot_weights.csv", row.names = TRUE)
write.csv(sum_boot_HTMT,  "boot_HTMT.csv", row.names = TRUE)



# Summarize the PLS-SEM bootstrapping outputs and take them to a single Excel file

# Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

wb <- createWorkbook()

# --- Bootstrap results ---
add_sheet(wb, "sum_boot_paths",     sum_boot_paths, headerStyle = header_style, borders = "all") # We need not run #sum_boot_model$bootstrapped_paths again

#=add_sheet(wb, "sum_boot_loadings",  sum_boot_loadings, headerStyle = header_style, borders = "all")  # We need not run #sum_boot_model$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights",   sum_boot_model$bootstrapped_weights, headerStyle = header_style, borders = "all")
add_sheet(wb, "sum_boot_HTMT",      sum_boot_model$bootstrapped_HTMT, headerStyle = header_style, borders = "all")

saveWorkbook(wb, "Promise Obj 1_Bootstrap.xlsx", overwrite = TRUE)



####################### FORMATTED VERSION WITH FUNCTION - BOOTSTRAPPING ######################################

# --- Create workbook for bootstrapping ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4F81BD",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}


# --- Bootstrap results ---
add_sheet(wb, "sum_boot_paths",     sum_boot_paths) # We need not run #sum_boot_model$bootstrapped_paths again

add_sheet(wb, "sum_boot_loadings",  sum_boot_loadings) # We need not run #sum_boot_model$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights",   sum_boot_model$bootstrapped_weights)
add_sheet(wb, "sum_boot_HTMT",      sum_boot_model$bootstrapped_HTMT)

# --- Save workbook ---
saveWorkbook(wb, "Promise PLS_SEM_with_Bootstrap-3.xlsx", overwrite = TRUE)

message("✅ Export complete: Bootstrap results written to Promise Obj 3_Bootstrap.xlsx")



  # Create the Visualization
  
 plot(pls_model,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()


# The bootstrapped model can also be visualized

 plot(boot_model,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()


# To save plot, we can also use:
# save_plot("plotname.png")




### Use of Lavaan package for analysis

  
lavms1 <- 
    # lavaan version
    model_lavaan <- '
  # Measurement model
  MAT =~ MAT1 + MAT2 + MAT3 + MAT4 + MAT5
  OP  =~ OP1 + OP2 + OP3 + OP4 + OP5
 

  # Structural model
  OP ~ MAT
'
  fit <- sem(lavms1, data = dt)
  semPlot::semPaths(fit, "std", whatLabels = "std")
  
  
  ## 9. Use semPlot's semPaths function for visualization
  semPaths(
    object       = fit,    # seminr model
    what         = "path",       # show path model
    whatLabels   = "est",        # show estimates
    style        = "lisrel",     # clean LISREL-style layout
    edge.label.cex = 1.0,        # font size for path coefficients
    sizeMan      = 6,            # indicator box size
    sizeLat      = 8,            # latent variable size
    residuals    = FALSE,        # hide residual arrows
    intercepts   = FALSE,        # hide intercepts
    layout       = "tree",       # top-down or left-right tree layout
    color        = list(lat = "blue", man = "yellow"), # node colors
    nCharNodes   = 0,            # don't shorten names
    asize        = 2,            # arrow thickness
    edge.color   = "black"       # arrow color
  )
  
  # Convert to semPlot-compatible object
 # sem_model <- semPlot::semPlotModel(fit)
  
  # Save to PNG
  
  ## 10. Save the plot as PNG
  png("pls_path_model_publication_ready1.png", width = 1600, height = 1000, res = 150)
  semPaths(
    object       = fit,
    what         = "path",
    whatLabels   = "est",
    style        = "lisrel",
    edge.label.cex = 1.2,
    sizeMan      = 6,
    sizeLat      = 8,
    residuals    = FALSE,
    intercepts   = FALSE,
    layout       = "tree",
    color        = list(lat = "blue", man = "yellow"),
    nCharNodes   = 0,
    asize        = 2,
    edge.color   = "black"
  )
  dev.off()
  
# To save plot, we can also use:
# save_plot("plotname.png")





    
    
######## Mediation Analysis ###############################################################################################
    
    
## Create the measurement model
  
  mm_med <- constructs(
    composite("MAT", multi_items("MAT", 1:5), weights = mode_A),
    composite("OP",  multi_items("OP", 1:5), weights = mode_A),
    composite("FL",  multi_items("FL", 1:4), weights = mode_A))  
    

  
  ## Create the structural model
  sm_med <- relationships(
    paths(from = "MAT", to = "OP"),
    paths(from = c("MAT", "FL", "MAT*FL"), to = "OP")
  )
  
  ## Create the structural model
  sm_med <- relationships(
    paths(from = "MAT", to = "OP"),
    paths(from = "MAT", to = "FL"),
    paths(from = "FL", to = "OP")  mediating effect
  )  # MODIFY 
  
  
 
  
  
  # Next, we estimate the model with estimate_pls(), store it to pl_sm_med and summarize it to sum_pls_med. Further, we also apply bootstrapping and summarize the bootstrapped model with an alpha level of 5% (summary(boot_corp_rep_med, alpha = 0.05))`
  
  ## Estimate the new model with mediator
  pl_sm_med <- estimate_pls(
    data = dt,
    measurement_model = mm_med,
    structural_model = sm_med,
    missing = mean_replacement,
    missing_value = "-99"
  )
  
  ## Extract the summary
  sum_pls_med <- summary(pl_sm_med)
  
  #### calling summary_pls_model$paths, we inspect the model's path coefficients and the (adjusted) R2 values 
  sum_pls_med$paths

  ### Inspect the total indirect effects
 sum_pls_med$total_indirect_effects 


 ### Inspect the total effects
sum_pls_med$total_effects
  

  #### calling summary_pls_model$reliability, we inspect the construct reliability metrics
  sum_pls_med$reliability
  
  
  #### we can plot the reliability
  plot(sum_pls_med$reliability)
  
  #### calling summary_pls_model$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & 	# Larcker, 1981)
  sum_pls_med$validity$fl_criteria
  
  #### Calling summary_pls_model$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
  sum_pls_med$validity$htmt
  
  
  ### Calling summary_pls_model$vif_antecedents, we inspect the VIF for collinearity
  sum_pls_med$vif_antecedents
  
  ### To get VIF
  sum_pls_med$validity$vif_items
  
  if(requireNamespace("car", quietly = TRUE)) {
    library(car)
    # Note: seminr does not directly give VIF; can compute VIF using construct scores
    lm2 <- lm(Loyalty ~ Satisfaction + Trust, data = construct_scores)
    vif_vals <- car::vif(lm2)
    print(vif_vals)
    write_csv(as.data.frame(vif_vals), "pls_vif_innermodel.csv")
  } 
  
  
  #### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
  sum_pls_med$descriptives$statistics$items
  
  ##. Outer loadings (indicator reliability)
  sum_pls_med$loadings
  
  ## Or
  outer_loadings_pl_sm_med <- pl_sm_med$outer_loadings
  print(outer_loadings_pl_sm_med)
  
  
  ##. weights
  pl_sm_med$outer_weights
  
  # Or
  outer_weights_pl_sm_med <- sum_pls_med$weights
  print(outer_weights_pl_sm_med)
  
  # Compute cross-loadings manually
  cross_loadings_pl_sm_med <- cor(dt, pl_sm_med$construct_scores, use = "pairwise.complete.obs")
  
  # Round for neatness
  round(cross_loadings_pl_sm_med, 4)
  
  
  # To get the effect size
  fsqaure_pls_med  <- sum_pls_med$fSquare
  
  
  #### To get the construct statistics.
  sum_pls_med$descriptives$statistics$constructs
  
  
  #### calling summary_pls_model$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
  sum_pls_med$paths
  
  #### calling summary_pls_model$reliability, we inspect the construct reliability metrics
  sum_pls_med$reliability
  
  
  #### we can plot the reliability
  plot(sum_pls_med$reliability)
  
  
  #### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
  sum_pls_med$descriptives$statistics$items
  
  
  #### To get the construct statistics.
  sum_pls_med$descriptives$statistics$constructs



### Calculate the sign of p1*p2*p3

sum_pls_med$paths["MAT","OP"]*sum_pls_med$paths["MAT","FL"]*sum_pls_med$paths["FL","OP"] # if positive, FL is a complementary partial mediator in # the relationship between MAT and OP
#if negative, FL is a compettive partial mediator in the relationship # between MAT and OP




  
  
# Saving the PL-SEM results to file

## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
sum_pls_med <- summary(pl_sm_med)

# Extract key components
total_effects_med <- sum_pls_med$total_effects
total_indirect_effects_med _med <- summary_pls_med$total_indirect_effects 
paths_med        <- sum_pls_med$paths
loadings_med     <- sum_pls_med$loadings
cross_loadings_med <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights_med      <- sum_pls_med$weights
rSquared_med     <- sum_pls_med$rSquared
reliability_med  <- sum_pls_med$reliability
htmt_med         <- sum_pls_med$htmt
fSquare_med      <- sum_pls_med$fSquare
collinearity_med <- sum_pls_med$validity$vif_items
collinearity2_med  <- sum_pls_med$vif_antecedents
fornell_larcker_med <-  sum_pls_med$validity$fl_criteria
items_statistics_med <- sum_pls_med$descriptives$statistics$items

sign_of_interaction <- sum_pls_med$paths["MAT","OP"]*sum_pls_med$paths["MAT","FL"]*sum_pls_med$paths["FL","OP"]

### Write each to CSV
write.csv(total_effects_med ,  "total_effects_med.csv", row.names = TRUE)
write.csv(total_indirect_effects_med , "total_indirect_effects_med.csv", row.names = TRUE)
write.csv(paths_med,       "paths_med.csv", row.names = FALSE)
write.csv(loadings_med,    "loadings_med.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings.csv", row.names = TRUE)
write.csv(weights_med,     "weights_med.csv", row.names = TRUE)
write.csv(rSquared_med,    "rSquared_med.csv", row.names = TRUE)
write.csv(reliability_med, "reliability_med.csv", row.names = TRUE)
write.csv(htmt_med,        "htmt_med.csv", row.names = TRUE)
write.csv(fSquare_med,     "fSquare_med.csv", row.names = TRUE)
write.csv(collinearity_med, "collinearity_med.csv", row.names = TRUE)
write.csv(collinearity2_med, "collinearity2_med.csv", row.names = TRUE)
write.csv(fornell_larcker_med,"fornell_larcker_med.csv", row.names = TRUE)
write.csv(items_statistics_med,"items_statistics_med.csv", row.names = TRUE)
write.csv(sign_of_interaction,"sign_of_interaction.csv", row.names = TRUE)






## Summarize the PLS-SEM model outputs and take them to a single Excel file
wb <- createWorkbook()
addWorksheet(wb, "total_effects_med"); writeData(wb, "total_effects_med ", sum_pls_med$total_effects)
addWorksheet(wb, "total_indirect_effects_med"); writeData(wb, "total_indirect_effects_med ", sum_pls_med$total_indirect_effects)
addWorksheet(wb, "Paths_med");        writeData(wb, "Paths_med", sum_pls_med$paths)
addWorksheet(wb, "Loadings_med");     writeData(wb, "Loadings_med", sum_pls_med$loadings)
addWorksheet(wb, "cross_loadings_med");     writeData(wb, "cross_loadings_med", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4))
addWorksheet(wb, "Weights_med");      writeData(wb, "Weights_med", sum_pls_med$weights)
addWorksheet(wb, "RSquared_med");     writeData(wb, "RSquared_med", sum_pls_med$rSquared)
addWorksheet(wb, "Reliability_med");  writeData(wb, "Reliability_med", sum_pls_med$reliability)
addWorksheet(wb, "HTMT_med");         writeData(wb, "HTMT_med", sum_pls_med$htmt)
addWorksheet(wb, "fSquare_med");      writeData(wb, "fSquare_med", sum_pls_med$fSquare)
addWorksheet(wb, "collinearity_med");  writeData(wb, "collinearity_med", sum_pls_med$validity$vif_items)
addWorksheet(wb, "collinearity2_med"); writeData(wb, "collinearity2_med", sum_pls_med$vif_antecedents)
addWorksheet(wb, "fornell_larcker_med"); writeData(wb, "fornell_larcker_med", sum_pls_med$validity$fl_criteria)
addWorksheet(wb, "items_statistics_med"); writeData(wb, "items_statistics_med", sum_pls_med$descriptives$statistics$items)

addWorksheet(wb, "sign_of_interaction"); writeData(wb, "items_statistics_med", sign_of_interaction)


saveWorkbook(wb, "Promise Objective med.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


## Summarize the PLS-SEM model ouputs and take them to their respective CSV files
sum_pls_med <- summary(pl_sm_med)

# Extract key components
total_effects_med <- sum_pls_med$total_effects
total_indirect_effects_med _med <- summary_pls_med$total_indirect_effects
paths_med        <- sum_pls_med$paths
loadings_med     <- sum_pls_med$loadings
cross_loadings_med <- round(cor(dt, pls_model$construct_scores, use = "pairwise.complete.obs"),4) 
weights_med      <- sum_pls_med$weights
rSquared_med     <- sum_pls_med$rSquared
reliability_med  <- sum_pls_med$reliability
htmt_med         <- sum_pls_med$htmt
fSquare_med      <- sum_pls_med$fSquare
collinearity_med <- sum_pls_med$validity$vif_items
collinearity2_med  <- sum_pls_med$vif_antecedents
fornell_larcker_med <-  sum_pls_med$validity$fl_criteria
items_statistics_med <- sum_pls_med$descriptives$statistics$items

# Write each to CSV
write.csv(total_effects_med ,  "total_effects_med .csv", row.names = TRUE)
write.csv(total_indirect_effects_med , "total_indirect_effects_med .csv", row.names = TRUE)
write.csv(paths_med,       "paths_med.csv", row.names = FALSE)
write.csv(loadings_med,    "loadings_med.csv", row.names = TRUE)
write.csv(cross_loadings,    "cross_loadings_med.csv", row.names = TRUE)
write.csv(weights_med,     "weights_med.csv", row.names = TRUE)
write.csv(rSquared_med,    "rSquared_med.csv", row.names = TRUE)
write.csv(reliability_med, "reliability_med.csv", row.names = TRUE)
write.csv(htmt_med,        "htmt_med.csv", row.names = TRUE)
write.csv(fSquare_med,     "fSquare_med.csv", row.names = TRUE)
write.csv(collinearity_med, "collinearity_med.csv", row.names = TRUE)
write.csv(collinearity2_med, "collinearity2_med.csv", row.names = TRUE)
write.csv(fornell_larcker_med,"fornell_larcker_med.csv", row.names = TRUE)
write.csv(items_statistics_med,"items_statistics_med.csv", row.names = TRUE)
write.csv(sign_of_interaction,"sign_of_interaction.csv", row.names = TRUE)


## Summarize the PLS-SEM model outputs and take them to a single Excel file

### Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)


wb <- createWorkbook()
addWorksheet(wb, "total_effects_med"); writeData(wb, "total_effects_med ", sum_pls_med$total_effects, headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects_med "); writeData(wb, "total_indirect_effects_med ", sum_pls_med$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths_med");        writeData(wb, "Paths_med", sum_pls_med$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings_med");     writeData(wb, "Loadings_med", sum_pls_med$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings_med");     writeData(wb, "cross_loadings_med", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle 																	= 															header_style, borders = "all")
addWorksheet(wb, "Weights_med");      writeData(wb, "Weights_med", sum_pls_med$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared_med");     writeData(wb, "RSquared_med", sum_pls_med$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability_med");  writeData(wb, "Reliability_med", sum_pls_med$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT_med");         writeData(wb, "HTMT_med", sum_pls_med$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare_med");      writeData(wb, "fSquare_med", sum_pls_med$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity_med");  writeData(wb, "collinearity_med", sum_pls_med$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2_med"); writeData(wb, "collinearity2_med", sum_pls_med$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker_med"); writeData(wb, "fornell_larcker_med", sum_pls_med$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics_med"); writeData(wb, "items_statistics_med", sum_pls_med$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")

addWorksheet(wb, "sign_of_interaction"); writeData(wb, "sign_of_interaction", sign_of_interaction, headerStyle = 									header_style, borders = "all")


saveWorkbook(wb, "Promise Objective med.xlsx", overwrite = TRUE)


####################### FORMATTED VERSION WITH FUNCTION ##########################################################################

# --- Create workbook ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}

# --- PLS model results ---
addWorksheet(wb, "total_effects_med"); writeData(wb, "total_effects_med ", sum_pls_med$total_effects, headerStyle = header_style, borders = "all")
addWorksheet(wb, "total_indirect_effects_med"); writeData(wb, "total_indirect_effects_med ", sum_pls_med$total_indirect_effects, headerStyle = 										header_style, borders = "all")
addWorksheet(wb, "Paths_med");        writeData(wb, "Paths_med", sum_pls_med$paths,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Loadings_med");     writeData(wb, "Loadings_med", sum_pls_med$loadings,, headerStyle = header_style, borders = "all")
addWorksheet(wb, "cross_loadings_med");     writeData(wb, "cross_loadings_med", round(cor(dt, pls_model$construct_scores, use = 															"pairwise.complete.obs"),4), headerStyle 																	= 															header_style, borders = "all")
addWorksheet(wb, "Weights_med");      writeData(wb, "Weights_med", sum_pls_med$weights, headerStyle = header_style, borders = "all")
addWorksheet(wb, "RSquared_med");     writeData(wb, "RSquared_med", sum_pls_med$rSquared, headerStyle = header_style, borders = "all")
addWorksheet(wb, "Reliability_med");  writeData(wb, "Reliability_med", sum_pls_med$reliability, headerStyle = header_style, borders = "all")
addWorksheet(wb, "HTMT_med");         writeData(wb, "HTMT_med", sum_pls_med$htmt, headerStyle = header_style, borders = "all")
addWorksheet(wb, "fSquare_med");      writeData(wb, "fSquare_med", sum_pls_med$fSquare, headerStyle = header_style, borders = "all")
addWorksheet(wb, "collinearity_med");  writeData(wb, "collinearity_med", sum_pls_med$validity$vif_items, headerStyle = header_style, borders = 										"all")
addWorksheet(wb, "collinearity2_med"); writeData(wb, "collinearity2_med", sum_pls_med$vif_antecedents, headerStyle = header_style, borders = 															"all")
addWorksheet(wb, "fornell_larcker_med"); writeData(wb, "fornell_larcker_med", sum_pls_med$validity$fl_criteria, headerStyle = header_style, 										borders = "all")
addWorksheet(wb, "items_statistics_med"); writeData(wb, "items_statistics_med", sum_pls_med$descriptives$statistics$items, headerStyle = 									header_style, borders = "all")

addWorksheet(wb, "sign_of_interaction"); writeData(wb, "sign_of_interaction", sign_of_interaction, headerStyle = 									header_style, borders = "all")



# ---  Save workbook ---
saveWorkbook(wb, "Promise Objective med.xlsx", overwrite = TRUE)

message("✅ Export complete: PLS results written to Promise Objective 1.xlsx")



  ### Bootstrapping the results
  boot_pls_med <- bootstrap_model(seminr_model = pl_sm_med,
                                  nboot = 1000,
                                  cores = NULL,
                                  seed = 123)
  
  ## Summarize the results of the bootstrap
  sum_boot_pls_med <- summary(boot_pls_med, alpha = 0.05) 


specific_direct_effect_sig_med <- specific_effect_significance(boot_pls_med, 
	from = "MAT",
	through = "FL",
	to = "OP",
	alpha = 0.05) # CONFIRM THE CORRECTNESS
 
  #### Obtain results on model estimates such as the path coefficients with sum_boot_pls_med$bootstrapped_paths.

  ######## Get the P-value and save the bootstrapping result to csv #################################

 sum_boot_paths_med <- sum_boot_pls_med$bootstrapped_paths

 ### Check the class of  sum_boot_paths_med

class(sum_boot_paths_med)


# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths_med)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_paths_med)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths) <- NULL

# Make Path the first column
sum_boot_paths_med  <- sum_boot_paths_med[, c("Path", setdiff(names(sum_boot_paths_med), "Path"))]


# Convert bootstrap results to data.frame 
  sum_boot_paths_med <- as.data.frame(sum_boot_pls_med$bootstrapped_paths)
  sum_boot_paths_med # Print to see the content
  

 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once

sum_boot_paths <- as.data.frame(sum_boot_paths) %>% 
  rownames_to_column(var = "Path")



  # Compute p-values (using "T Stat." column with dot)
  sum_boot_paths_med$p_value <- round(2 * (1 - pnorm(abs(sum_boot_paths_med[,"T Stat."]))),4)
  
  colnames(sum_boot_paths_med)
  head(sum_boot_paths_med)
  
  # Add significance levels
  sum_boot_paths_med$Significance <- cut(
    sum_boot_paths_med$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  
  # Create a clean table with selected columns
  paths_clean_results_med <- sum_boot_paths_med[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                        "2.5% CI","97.5% CI", "p_value" ,      
                                        "Significance" )]
  
  # Rename columns for clarity
  colnames(sum_boot_paths_med) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                 "2.5% CI","97.5% CI", "p_value" ,      
                                 "Significance" )
  
  
  # Export to CSV (saves in working directory)
  write.csv(
    paths_clean_results_med,
    file = "paths_bootstrap_results_med.csv",
    row.names = TRUE
  )
  


  # Confirm location
  cat("✅ Clean results with CIs saved as 'paths_bootstrap_results_med.csv' in your working directory\n")
  
  
  
  ###### Writing the bootstrapping as a function (optional)
  
  export_bootstrap_results <- function(pathbootstrap, filename = "paths_bootstrap_results_med.csv") {


 ### Check the class of  sum_boot_paths_med

class( sum_boot_paths_med)


# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_paths_med)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_paths_med)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_paths_med) <- NULL

# Make Path the first column
sum_boot_paths_med  <- sum_boot_paths_med[, c("Path", setdiff(names(sum_boot_paths), "Path"))]


 # Convert bootstrap results to data.frame
    sum_boot_paths_med <- as.data.frame(sum_boot_pls_med$bootstrapped_paths)
    
    # Compute p-values (using "T Stat." column with dot)
    sum_boot_paths_med$p_value <- 2 * (1 - pnorm(abs(sum_boot_paths_med[,"T Stat."])))
    
    # Add significance levels
    sum_boot_paths_med$Significance <- cut(
      sum_boot_paths_med$p_value,
      breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
      labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
    )
    
    # Create a clean table with selected columns
    paths_clean_results_med <- sum_boot_paths_med[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                         "2.5% CI","97.5% CI", "p_value" ,      
                                         "Significance" )]
    
    # Rename columns for clarity
    colnames(paths_clean_results_med) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                   "2.5% CI","97.5% CI", "p_value" ,      
                                   "Significance" )
    
    # Export to CSV
    
    write.csv(
      paths_clean_results_med,
      file = "bootstrap_results_med.csv",
      row.names = TRUE
    )
    
    # Confirm location
    cat("✅ Clean results with CIs saved as 'paths_bootstrap_results_med.csv' in your working directory\n")
    
    
  }
  
  export_bootstrap_results(pathbootstrap)


  
  #### Bootstrapping of outer loadings 
  ####### Get the P-value and save the bootstrapping result to csv #################################



 sum_boot_loadings_med  <- sum_boot_model$bootstrapped_loadings

 ### Check the class of  sum_boot_loadings

class(sum_boot_loadings_med)

# Check the rownames which is expected to be the paths values with no recognized column header

rownames(sum_boot_loadings_med)

# Now create a column for the rownames 
sum_boot_paths$Path <- rownames(sum_boot_loadings_med)

### Set the rownames to null, so it is no more appearing
rownames(sum_boot_loadings_med) <- NULL

# Make Loadings the first column 
sum_boot_loadings_med <- sum_boot_loadings_med[, c("Loadings", setdiff(names(sum_boot_loadings_med), "Loadings"))]


  # Convert bootstrap results to data.frame 
  
  sum_boot_loadings_med <- as.data.frame(sum_boot_pls_med$bootstrapped_loadings)
  sum_boot_loadings_med # Print to see the contents



 ### Alternatively,:
 #### Create a column name for the rownames, 
 #### setting the rownames to null and make it disappear, as we have it under a column now
 #### Make it the first column 
 ### All at once
sum_boot_loadings_med<- as.data.frame(sum_boot_loadings_med) %>%  
  rownames_to_column(var = "Loadings") # Won’t be used inside the function version at the same time as the above 


  
  # Compute p-values (using "T Stat." column with dot)
   sum_boot_loadings_med$p_value <- round(2 * (1 - pnorm(abs( sum_boot_pls_med_loadings[,"T Stat."]))),4)
  
  ### Get the column headers
  colnames(sum_boot_loadings_med)
  head(sum_boot_loadings_med)
  
  # Add significance levels
   sum_boot_loadings_med$Significance <- cut(
     sum_boot_loadings_med$p_value,
    breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
    labels = c("p < 0.001", "p < 0.01", "p < 0.05", "ns")
  )
  
  # Create a clean table with selected columns
  clean_results_loadings_med <- sum_boot_loadings_med[, c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                      "2.5% CI","97.5% CI", "p_value" ,      
                                      "Significance" )]
  
  # Rename columns for clarity
  colnames(clean_results_loadings_med) <-  c("Original Est.",  "Bootstrap Mean", "Bootstrap SD",  "T Stat.",
                                "2.5% CI","97.5% CI", "p_value" ,      
                                "Significance" )
    
  
  # Export to CSV (saves in working directory)
  write.csv(
    clean_results_loadings_med,
    file = "loadings_boostrap_med.csv",
    row.names = TRUE
  )
  
  # Confirm location
  cat("✅ Clean results of loadings with CIs saved as 'loadings_boostrap_med.csv' in your working directory\n")
 

# Saving the bootstrapping results to file

## Summarize the PLS-SEM Bootstrapping outputs and take them to their respective CSV files

sum_boot_pls_med <- summary(boot_pls_med, , alpha = 0.05) 

### Extract key components
sum_boot_paths_med <- sum_boot_paths_med # No need to run the sum_boot_loadings_med$bootstrapped_paths again, since one containing the p-value and  	#significance is available above

# sum_boot_loadings_med <-  sum_boot_pls_med # No need to run the sum_boot_loadings$bootstrapped_loadings again, since one containing the p-value and     	#significance is available above

sum_boot_weights_med  <- sum_boot_pls_med$bootstrapped_weights
sum_boot_HTMT_med     <- sum_boot_pls_med$bootstrapped_HTMT


### Write each to CSV
write.csv(sum_boot_paths_med,  "boot_paths_med.csv", row.names = TRUE)
write.csv(sum_boot_loadings_med,  "boot_loadings_med.csv", row.names = TRUE)
write.csv(sum_boot_weights_med,  "boot_weights_med.csv", row.names = TRUE)
write.csv(sum_boot_HTMT_med,  "boot_HTMT_med.csv", row.names = TRUE)


## Summarize the PLS-SEM Bootstrapping  outputs and take them to a single Excel file
wb <- createWorkbook()
#add_sheet(wb, "sum_boot_paths_med",     sum_boot_paths_med)  #We need not run sum_boot_pls_med$bootstrapped_paths again
#add_sheet(wb, "sum_boot_loadings_med",  sum_boot_loadings_med) # We need not run sum_boot_pls_med$bootstrapped_loadings again
add_sheet(wb, "sum_boot_weights_med",   sum_boot_pls_med$bootstrapped_weights_med)
add_sheet(wb, "sum_boot_HTMT_med",      sum_boot_pls_med$bootstrapped_HTMT_med)

saveWorkbook(wb, " Promise PLS_SEM_with_BootstrapMed.xlsx", overwrite = TRUE)




####################### FORMATTED VERSION ##########################################################################


# Summarize the PLS-SEM bootstrapping outputs and take them to a single Excel file


# Extract key components
#sum_boot_paths <- sum_boot_pls_med$bootstrapped_paths
#sum_boot_loadings <-  sum_boot_pls_med$bootstrapped_loadings
sum_boot_weights  <- sum_boot_pls_med$bootstrapped_weights
sum_boot_HTMT     <- sum_boot_pls_med$bootstrapped_HTMT


# Write each to CSV
write.csv(sum_boot_paths,  "boot_paths.csv", row.names = TRUE)
write.csv(sum_boot_loadings,  "boot_loadings.csv", row.names = TRUE)
write.csv(sum_boot_weights,  "boot_weights.csv", row.names = TRUE)
write.csv(sum_boot_HTMT,  "boot_HTMT.csv", row.names = TRUE)



# Summarize the PLS-SEM bootstrapping outputs and take them to a single Excel file

# Define a reusable header style
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "black",
  halign     = "center",
  fgFill     = "#4FBD81",
  border     = "Bottom"
)

wb <- createWorkbook()

# --- Bootstrap results ---
#add_sheet(wb, "sum_boot_paths_med",     sum_boot_pls_med$bootstrapped_paths,headerStyle = header_style, borders = "all") # We need not run #sum_boot_pls_med$bootstrapped_paths again

#add_sheet(wb, "sum_boot_loadings_med",  sum_boot_pls_med$bootstrapped_loadings, headerStyle = header_style, borders = "all")  # We need not run #sum_boot_pls_med$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights_med",   sum_boot_pls_med$bootstrapped_weights, headerStyle = header_style, borders = "all")
add_sheet(wb, "sum_boot_HTMT_med",      sum_boot_pls_med$bootstrapped_HTMT, headerStyle = header_style, borders = "all")
saveWorkbook(wb, " Promise PLS_SEM_with_BootstrapMed.xlsx ", overwrite = TRUE)



####################### FORMATTED VERSION WITH FUNCTION - BOOTSTRAPPING ######################################

# --- Create workbook for bootstrapping ---
wb <- createWorkbook()

# --- Define a reusable header style ---
header_style <- createStyle(
  fontSize   = 12,
  fontColour = "white",
  halign     = "center",
  fgFill     = "#4F81BD",
  border     = "Bottom"
)

# --- Helper to add sheets safely ---
add_sheet <- function(wb, sheet_name, data) {
  if (!is.null(data)) {
    addWorksheet(wb, sheet_name)
    writeData(wb, sheet_name, data, headerStyle = header_style, borders = "all")
    setColWidths(wb, sheet_name, cols = 1:ncol(dt), widths = "auto")
  }
}


# --- Bootstrap results ---
add_sheet(wb, "sum_boot_paths_med",     sum_boot_paths_med) # We need not run #sum_boot_pls_med$bootstrapped_paths again

#add_sheet(wb, "sum_boot_loadings_med", sum_boot_loadings_med) # We need not run #sum_boot_pls_med$bootstrapped_loadings again

add_sheet(wb, "sum_boot_weights_med",   sum_boot_pls_med$bootstrapped_weights)
add_sheet(wb, "sum_boot_HTMT_med",      sum_boot_pls_med$bootstrapped_HTMT)

# --- Save workbook ---
saveWorkbook(wb, "Promise PLS_SEM_with_BootstrapMed.xlsx", overwrite = TRUE)

message("✅ Export complete: Bootstrap results written to Promise PLS_SEM_with_BootstrapMed.xlsx")


  # Create the Visualization
  
 plot(pl_sm_med,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()

# The bootstrapped model can also be visualized

 plot(boot_pls_med,
     what = "paths",
     engine = "DiagrammeR",
     title = TRUE,
     node_labels = TRUE,
     node_color = "lightgreen",
     node_shape = "ellipse",
     fontname = "Arial",
     fontsize = 12,
     edge_labels = TRUE,
     edge_label_color = "black",
     edge_color = "darkblue",
     edge_width = 2,
     layout = "tree")
dev.off()

# To save plot, we can also use:
# save_plot("plotname.png")

### Use of Lavaan package for analysis

  # Step 1: Specify the measurement + main effects model
  model_main <- '
  # Measurement
  MAT =~ MAT1 + MAT2 + MAT3 + MAT4 + MAT5
  FL  =~ FL1 + FL2 + FL3 + FL4
  OP  =~ OP1 + OP2 + OP3 + OP4 + OP5

  # Structural (main effects only)
  OP ~ MAT + FL
'
  
  fit_main <- sem(model_main, data = data)
  
  # Step 2: Save factor scores to build interaction term
  fscores <- lavPredict(fit_main)   # gives factor scores for MAT, FL, OP
  data$MATxFL <- fscores[,"MAT"] * fscores[,"FL"]
  
  model_med <- '
  # Measurement
  MAT =~ MAT1 + MAT2 + MAT3 + MAT4 + MAT5
  FL  =~ FL1 + FL2 + FL3 + FL4
  OP  =~ OP1 + OP2 + OP3 + OP4 + OP5

  # Structural with mederation
  OP ~ MAT + FL + MATxFL
'
  
  fit_med <- sem(model_med, data = dt)
  
  # Step 3. Plot
  semPaths(fit_med, "std", whatLabels = "std", edge.label.cex = 1.2)
  
  
  ## 9. Use semPlot's semPaths function for visualization
  semPaths(
    object       = fit_med,    # seminr model
    what         = "path",       # show path model
    whatLabels   = "est",        # show estimates
    style        = "lisrel",     # clean LISREL-style layout
    edge.label.cex = 1.0,        # font size for path coefficients
    sizeMan      = 6,            # indicator box size
    sizeLat      = 8,            # latent variable size
    residuals    = FALSE,        # hide residual arrows
    intercepts   = FALSE,        # hide intercepts
    layout       = "tree",       # top-down or left-right tree layout
    color        = list(lat = "blue", man = "yellow"), # node colors
    nCharNodes   = 0,            # don't shorten names
    asize        = 2,            # arrow thickness
    edge.color   = "black"       # arrow color
  )
  
  
  ## 10. Save the plot as PNG
  png("pls_path_model_publication_ready_med.png", width = 1600, height = 1000, res = 150)
  semPaths(
    object       = fit_med,
    what         = "path",
    whatLabels   = "est",
    -   style        = "lisrel",
    edge.label.cex = 1.2,
    sizeMan      = 6,
    sizeLat      = 8,
    residuals    = FALSE,
    intercepts   = FALSE,
    layout       = "tree",
    color        = list(lat = "blue", man = "yellow"),
    nCharNodes   = 0,
    asize        = 2,
    edge.color   = "black"
  )
  dev.off()

  
  







    
    
    
  