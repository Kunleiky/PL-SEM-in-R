 # PL-SEM in R - Sample data

## PL-SEM with Sample data provided with the booK: Partial Least Squares Structural Equation Modeling (PLS-SEM) Using R ######
## by Joseph Hair, Tomas Hult, Christian M. Ringle, Marko Sarstedt, Nicholas Danks, and Soumya Ray.#####

### 1. Installing and loading the package
##### Import the libary
library(seminr)
##### Load the data from the seminr package
corp_rep_data <- seminr::corp_rep_data
#### Alternatively, you can load the data if available in a file in a folder
#### corp_rep_data <- read.csv(file = "Corporate Reputation Data.csv", 
####  header = TRUE, sep = ";")

#### Take a quick look at the data with
head(corp_rep_data)

## Model and measurement details
## Variables in the data #To be created as a table 
## Tab. 1 Measurement details for the simple corporate reputation model.
**construct	variable name	item
Competence (COMP)	comp_1	[The company] is a top competitor in its market.
Competence (COMP)	comp_2	As far as I know, [the company] is recognized worldwide.
Competence (COMP)	comp_3	I believe that [the company] performs at a premium level.
Likeability (LIKE)	like_1	[The company] is a company that I can better identify with than other companies.
Likeability (LIKE)	like_2	[The company] is a company that I would regret more not having if it no longer existed than I would other companies.
Likeability (LIKE)	like_3	I regard [the company] as a likeable company.
Customer Satisfaction (CUSA)	cusa	I am satisfied with [the company].
Customer Loyalty (CUSL)	cusl_1	I would recommend [company] to friends and relatives.
Customer Loyalty (CUSL)	cusl_2	If I had to choose again, I would choose [company] as my mobile phone services provider.
Customer Loyalty (CUSL)**

`# The constructs() function specifies the list of all construct measurement models. Within this list you can define various constructs`
`# composite() specifies the measurement of individual constructs.`
`# interaction_term() specifies interactions terms.`
`# higher_composite() specifies hierarchical component models, i.e. higher-order constructs (Sarstedt et al., 2019)`

# composite() specifies the measurement of individual constructs and
# multi_items() creates a vector of multiple measurement items with similar names.
# single_item() describe a single measurement item.

### 2. Create a measurement model
corp_rep_mm <- constructs(
  composite("COMP", multi_items("comp_", 1:3)),
  composite("LIKE", multi_items("like_", 1:3)),
  composite("CUSA", single_item("cusa")),
  composite("CUSL", multi_items("cusl_", 1:3)))

### 3. Create a structural model
` ############ The structural model indicates the sequence of the constructs and the relationships between them.` 
`############# relationships() specifies all the structural relationships between all constructs.`
`########### paths() specifies relationships between a specific set of antecedents and outcomes.`

corp_rep_sm <- relationships(
  paths(from = c("COMP", "LIKE"), to = c("CUSA", "CUSL")),
  paths(from = c("CUSA"), to = c("CUSL")))

### 4. Estimating the model

`###### To estimate a PLS path model, algorithmic options and arguments settings must be selected. `
`###### These can be reviewed by calling the function’s documentation with ?estimate_pls`

`## Here, we specify the data (data = corp_rep_data), 
the measurement model (measurement_model = corp_rep_mm) and structural model (structural_model  = corp_rep_sm) as well as
the weighting scheme (inner_weights = path_weighting) and missing data handling with missing values being indicated by “-99” (missing_value = "-99") and
replaced by the mean (missing = mean_replacement).`

corp_rep_pls_model <- estimate_pls(data = corp_rep_data,
  measurement_model = corp_rep_mm,
  structural_model  = corp_rep_sm,
  inner_weights = path_weighting,
  missing = mean_replacement,
  missing_value = "-99")


### 5. Summarizing the model
` # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.`
summary_corp_rep <- summary(corp_rep_pls_model)

`# The summary() function applied to a SEMinR model object produces a summary.seminr_model class object. 
#Its sub-objects (see Tab. 2) serve as basis for the assessment of the measurement and structural model (Hair et al., 2019).`


## Objects available in the usmmary summary.seminr_model class object produced by the summary() function. To be created as a table
**Tab. 2 Elements of the summary.seminr_model object.
Sub-object	Content
meta	The estimation function and version information.
iterations	The number of iterations for the PLS algorithm to converge.
paths	The model’s path coefficients and (adjusted) R2 values.
total_effects	The model’s total effects.
total_indirect_effects	The model’s total indirect effects.
loadings	The outer loadings for all constructs.
weights	The outer weights for all constructs.
validity	The metrics necessary to evaluate the construct measures’ validity.
reliability	The metrics necessary to evaluate the construct measures’ reliability.
composite_scores	The estimated scores for constructs.
vif_antecedents	The metrics used to evaluate structural model collinearity.
fSquare	The f2 metric for all structural model relationships.
descriptives	The descriptive statistics of the indicator data.
it_criteria	The Information Theoretic model selection criteria for the estimated model.**

#### calling summary_corp_rep$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
summary_corp_rep$paths

#### calling summary_corp_rep$reliability, we inspect the construct reliability metrics
summary_corp_rep$reliability

#### we can plot the reliability
plot(summary_corp_rep$reliability)
#### calling summary_corp_rep$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
summary_corp_rep$validity$fl_criteria

#### Calling summary_corp_rep$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
summary_corp_rep$validity$htmt


`# We recommend the heterotrait-monotrait ratio (HTMT) of the correlations to assess discriminant validity (Henseler et al., 2015).
The HTMT is the mean value of the indicator correlations across constructs (i.e., the heterotrait-heteromethod correlations) relative to the (geometric) mean of the average correlations for the indicators measuring the same construct (i.e., the monotrait-heteromethod correlations).
Discriminant validity problems are present when HTMT values
exceed 0.90 for constructs that are conceptually very similar.
exceed 0.85 for constructs that are conceptually more distinct.`
### Calling summary_corp_rep$vif_antecedents, we inspect the VIF for collinerity
summary_corp_rep$vif_antecedents

#### check if and when the algorithm converged, we can inspect the number of iterations in summary_corp_rep$iterations.
summary_corp_rep$iterations
#### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
summary_corp_rep$descriptives$statistics$items

#### To get the construct statistics.
summary_corp_rep$descriptives$statistics$constructs

## 6. Bootstrapping the model
`# In PLS-SEM, we need to perform bootstrapping to estimate standard errors and compute confidence intervals.`
`We run the bootstrapping with the bootstrap_model() function with 1,000 (or any other number) subsamples (nboot = 1000) and set a seed (seed = 123) to obtain reproducible results.`

`# Next, we summarize the bootstrap model with sum_boot_corp_rep <- summary(boot_corp_rep)`

Copyboot_corp_rep <- bootstrap_model(seminr_model = corp_rep_pls_model,
  nboot = 1000,
  cores = NULL,
  seed = 123)
sum_boot_corp_rep <- summary(boot_corp_rep)

#### Obtain results on model estimates such as the path coefficients with sum_boot_corp_rep$bootstrapped_paths.
sum_boot_corp_rep$bootstrapped_paths


***The summary.boot_seminr_model object, i.e. sum_boot_corp_rep, contains the following sub-objects (Tab. 3): #To be created as table
Tab. 3 Elements of the summary.boot_seminr_model object.
Sub-object	Content
nboot	The number of bootstrap subsamples generated during bootstrapping.
bootstrapped_paths	The bootstrap estimated standard error, T statistic, and confidence intervals for the path coefficients.
bootstrapped_weights	The bootstrap estimated standard error, T statistic, and confidence intervals for the indicator weights.
bootstrapped_loadings	The bootstrap estimated standard error, T statistic, and confidence intervals for the indicator loadings.
bootstrapped_HTMT	The bootstrap estimated standard error, T statistic, and confidence intervals for the HTMT values.
bootstrapped_total_paths	The bootstrap estimated standard error, T statistic, and confidence intervals for the model’s total effects.***


# Mediation Analysis
`# Mediation occurs when a construct, referred to as mediator construct, intervenes between two other related constructs (see Fig. 5 for a generic mediation model). Direct effects are the relationships linking two constructs with a single arrow (p1, p2, and p3). 
Indirect effects represent a sequence of relationships with at least one intervening construct. Thus, an indirect effect is a sequence of two or more direct effects (p1 and p2) and is represented visually by multiple arrows`

` #The results for the indirect effects (p 1 ∗p 2 ) can be found by inspecting the total_indirect_effects element within the summary_corp_rep_ext object.`
summary_corp_rep$total_indirect_effects

`# Specific indirect paths can be evaluated for significance by using the specific_effect_significance() function. This function takes a bootstrapped model object (boot_seminr_model = boot_corp_rep_ext), an antecedent construct name (from = "COMP, respectively from = "LIKE), a mediator construct name (through = "CUSA") and an outcome construct name (to = "CUSL") as arguments and returns the confidence interval (e.g. with alpha = 0.05) for the total indirect paths from the antecedent to the outcome construct.
Note that for serial mediation models, the through argument can take multiple mediating constructs as arguments (e.g. through = c("construct1", "construct2”)).
For example, the specific indirect effects for the paths from COMP through CUSA to CUSL and LIKE through CUSA to CUSL are:`

specific_effect_significance(boot_seminr_model = boot_corp_rep, 
  from = "COMP", 
  through = "CUSA", 
  to = "CUSL", 
  alpha = 0.05)

specific_effect_significance(boot_corp_rep_ext, 
  from = "LIKE", 
  through = "CUSA", 
  to = "CUSL", 
  alpha = 0.05)


 ` # We consider both the indirect (p 1 ∗p 2 
) and the direct effects (p 3 
) to determine the mediation type, respectively the non-mediation type (Zhao et al., 2010).
Zhao et al. (2010) identify three types of mediation:
Complementary mediation: The indirect effect as well as the direct effect are significant and point in the same direction. The product of indirect and direct effects (p 1 ∗p 2 ∗p 3 ) has a positive sign.
Competitive mediation: The indirect effect as well as the direct effect are significant, but point in opposite directions. The product of indirect and direct effects (p 1 ∗p 2 ∗p 3 ) has a negative sign.
Indirect-only mediation: The indirect effect is significant but not the direct effect.
In addition, they characterize two types of non-mediation:
Direct-only non-mediation: The direct effect is significant but not the indirect effect.
No-effect non-mediation: Neither the direct nor the indirect effect are significant.`

`The direct effects (e.g. COMP on CUSL and LIKE on CUSL) can be accessed by the inspecting summary_corp_rep_ext$paths. The confidence intervals for the direct effects are stored in summary_boot_corp_rep$bootstrapped_paths`
summary_corp_rep$paths
summary_boot_corp_rep$bootstrapped_paths

` #To evaluate if CUSA acts as a complementary or competitive mediator for the effect of LIKE, respectively COMP, on CUSL, we determine whether the product of indirect and direct effects (p 1 ∗p 2 ∗p 3 
) has a positive or negative sign.
We can subset the path matrix to access the path coefficients for p1, p2, and p3 (e.g. from LIKE to CUSA: summary_corp_rep_ext$paths[“LIKE”, “CUSA”].`

# Calculate the sign of p1*p2*p3 with LIKE as antecedent/independent variable
summary_corp_rep_ext$paths["LIKE", "CUSL"] *
  summary_corp_rep_ext$paths["LIKE","CUSA"] * 
  summary_corp_rep_ext$paths["CUSA","CUSL"]

  # Calculate the sign of p1*p2*p3 for COMP as antecedent/independent variable
summary_corp_rep_ext$paths["COMP", "CUSL"] *
  summary_corp_rep_ext$paths["COMP","CUSA"] * 
  summary_corp_rep_ext$paths["CUSA","CUSL"]

  # Moderation Analysis
` # Moderation describes a situation in which the relationship between two constructs is not constant but depends on the values of a third variable, referred to as a moderator variable. The moderator variable (or construct) changes the strength or even the direction of a relationship between two constructs in the model.`

`# Interaction terms are described in the measurement model functionconstructs() using the following methods:
product_indicator generates the interaction term by multiplying each indicator of the exogenous construct with each indicator of the moderator variable.
orthogonal is an extension of the product indicator approach, which generates an interaction term whose indicators do not share any variance with the indicators of the exogenous construct and the moderator. The orthogonalizing approach is typically used to handle multicollinearity in the structural model.
two-stage specifies the interaction term as the product of the latent scores of the exogenous construct and moderator variable.`

` # While specifying the measurement model, we add the interaction term between the independent variable CUSA and the moderator variable SC and apply the two stage approach as follows: interaction_term(iv = "CUSA", moderator = "SC", method = two_stage).`

` # Further, we add the path linkingCUSA*SC to CUSL to the structural model in paths(from = c("CUSA", "SC", "CUSA*SC"), to = c("CUSL"))`

# Create the measurement model
corp_rep_mm_mod <- constructs(
  composite("QUAL", multi_items("qual_", 1:8), weights = mode_B),
  composite("PERF", multi_items("perf_", 1:5), weights = mode_B),
  composite("CSOR", multi_items("csor_", 1:5), weights = mode_B),
  composite("ATTR", multi_items("attr_", 1:3), weights = mode_B),
  composite("COMP", multi_items("comp_", 1:3)),
  composite("LIKE", multi_items("like_", 1:3)),
  composite("CUSA", single_item("cusa")),
  composite("SC", multi_items("switch_", 1:4)),
  composite("CUSL", multi_items("cusl_", 1:3)),
  interaction_term(iv = "CUSA", moderator = "SC", method = two_stage))

# Create the structural model
corp_rep_sm_mod <- relationships(
  paths(from = c("QUAL", "PERF", "CSOR", "ATTR"), to = c("COMP", "LIKE")),
  paths(from = c("COMP", "LIKE"), to = c("CUSA", "CUSL")),
  paths(from = c("CUSA", "SC", "CUSA*SC"), to = c("CUSL"))
)

` #Next, we estimate the model with estimate_pls(), store it to corp_rep_pls_model_mod and summarize it to sum_corp_rep_mod. Further, we also apply bootstrapping and summarize the bootstrapped model with an alpha level of 5% (summary(boot_corp_rep_mod, alpha = 0.05))`

# Estimate the new model with moderator
corp_rep_pls_model_mod <- estimate_pls(
  data = corp_rep_data,
  measurement_model = corp_rep_mm_mod,
  structural_model = corp_rep_sm_mod,
  missing = mean_replacement,
  missing_value = "-99"
)
## Generating the seminr model
## All 344 observations are valid.

# Extract the summary
sum_corp_rep_mod <- summary(corp_rep_pls_model_mod)

# Bootstrap the model
boot_corp_rep_mod <- bootstrap_model(
  seminr_model = corp_rep_pls_model_mod,
  nboot = 1000)

# Summarize the results of the bootstrap
sum_boot_corp_rep_mod <- summary(boot_corp_rep_mod, alpha = 0.05)

`# In order to evaluate the moderating effect, we inspect the bootstrapped_paths element in the sum_boot_corp_rep_mod object.`
sum_boot_corp_rep_mod$bootstrapped_paths
` #To better comprehend the results of the moderator analysis, we use the slope_analysis() function to visualize the two-way interaction effect. Therefore, we specify the model (moderated_model = corp_rep_pls_model_mod), the dependent variable (dv = "CUSL"), the moderator (moderator = "SC"), and the independent variable (iv = "CUSA") as well as the legend’s position (leg_place = "bottomright").`
slope_analysis(
  moderated_model = corp_rep_pls_model_mod,
  dv = "CUSL",
  moderator = "SC",
  iv = "CUSA",
  leg_place = "bottomright")



-----------------------------------------------------------------------------------------------------------------------------------------------------------


# GPT Generated 
## 1. Install and load required packages
if(!require(seminr)) install.packages("seminr", repos="https://cloud.r-project.org")
if(!require(semPlot)) install.packages("semPlot", repos="https://cloud.r-project.org")
if(!require(seminr)) install.packages("seminr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(semPlot)) install.packages("semPlot", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(dplyr)) install.packages("dplyr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(tibble)) install.packages("tibble", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(readr)) install.packages("readr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(ggplot2)) install.packages("ggplot2", repos="https://cloud.r-project.org")
library(tibble)
library(readr)
library(ggplot2)
library(seminr)
library(semPlot)
library(dplyr)


## 2. Load in the data
data <- read.csv("path/semdata.csv")

 ## 2. Define measurement model
mm <- constructs(
  composite("Image", multi_items("IMAG", 1:5)),
  composite("Loyalty", multi_items("LOY", 1:5)),
  composite("Satisfaction", multi_items("SAT", 1:5))
)

## 3. Structural model
sm <- relationships(
  paths(from = "Image", to = c("Satisfaction", "Loyalty")),
  paths(from = "Satisfaction", to = "Loyalty")
)

## 4. Estimate model
pls_model <- estimate_pls(data = data, measurement_model = mm, structural_model = sm)
summary(pls_model)

paths <- pls_model$path_coefficients
print(paths)

## 5. Convert PLS model to a semPlot-compatible object
# seminr doesn't directly integrate, so we adapt using lavaan-like format
# First, get path relationships
paths <- pls_model$path_coefficients
print(paths)

## 6. Get R² values for endogenous constructs
r2_vals <- pls_model$rSquared
print(r2_vals)

## 7. Use semPlot's semPaths function for visualization
semPaths(
  object       = pls_model,    # seminr model
  what         = "path",       # show path model
  whatLabels   = "est",        # show estimates
  style        = "lisrel",     # clean LISREL-style layout
  edge.label.cex = 1.0,        # font size for path coefficients
  sizeMan      = 6,            # indicator box size
  sizeLat      = 8,            # latent variable size
  residuals    = FALSE,        # hide residual arrows
  intercepts   = FALSE,        # hide intercepts
  layout       = "tree",       # top-down or left-right tree layout
  color        = list(lat = "lightblue", man = "yellow"), # node colors
  nCharNodes   = 0,            # don't shorten names
  asize        = 2,            # arrow thickness
  edge.color   = "black"       # arrow color
)


## 8. Save the plot as PNG
png("pls_path_model_publication_ready.png", width = 1600, height = 1000, res = 150)
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "est",
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "yellow"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)
dev.off()




# Script — Path Model with Significance Stars #########

## 1. Install and load required packages 
if(!require(seminr)) install.packages("seminr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(semPlot)) install.packages("semPlot", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(dplyr)) install.packages("dplyr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(tibble)) install.packages("tibble", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(readr)) install.packages("readr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(ggplot2)) install.packages("ggplot2", repos="https://cloud.r-project.org")
library(tibble)
library(readr)
library(ggplot2)
library(seminr)
library(semPlot)
library(dplyr)


## 2. Assume pls_model is already estimated ---
# If not, run your previous estimation code here before proceeding

## 3. Bootstrap to get p-values
set.seed(123)
boot_results <- bootstrap_model(pls_model, nboot = 2000, cores = 2)
boot_paths <- as.data.frame(boot_results$paths)

## 4. Create significance stars based on p-values
boot_paths <- boot_paths %>%
  mutate(
    stars = case_when(
      p_val < 0.001 ~ "***",
      p_val < 0.01  ~ "**",
      p_val < 0.05  ~ "*",
      TRUE          ~ ""
    ),
    label = paste0(round(Original, 2), stars)
  )

## 5. Prepare a matrix of labels for semPlot
# semPlot expects a matrix where row = from, col = to
constructs <- rownames(pls_model$path_coefficients)
label_matrix <- matrix("", nrow = length(constructs), ncol = length(constructs),
                       dimnames = list(constructs, constructs))

for (i in seq_len(nrow(boot_paths))) {
  from <- boot_paths$Path[i] %>% strsplit(" -> ") %>% .[[1]][1]
  to   <- boot_paths$Path[i] %>% strsplit(" -> ") %>% .[[1]][2]
  label_matrix[from, to] <- boot_paths$label[i]
}

## 6. Plot with semPaths using our custom labels
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "no",         # we'll override with custom labels
  edgeLabels   = label_matrix, # custom path labels
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "white"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)

## 7. Save the plot to PNG
png("pls_path_model_with_stars.png", width = 1600, height = 1000, res = 150)
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "no",
  edgeLabels   = label_matrix,
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "white"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)
dev.off()

message("Plot saved as pls_path_model_with_stars.png in your working directory")


# Path Model with Stars & R² #

## 1. Install and load required packages ---
if(!require(seminr)) install.packages("seminr", repos="https://cloud.r-project.org")
if(!require(semPlot)) install.packages("semPlot", repos="https://cloud.r-project.org")
if(!require(dplyr)) install.packages("dplyr", repos="https://cloud.r-project.org")
if(!require(stringr)) install.packages("stringr", repos="https://cloud.r-project.org")
library(seminr)
library(semPlot)
library(dplyr)
library(stringr)

## 2. Assume pls_model is already estimated
# If not, run your estimation code here before proceeding

### 3. Bootstrap to get p-values
set.seed(123)
boot_results <- bootstrap_model(pls_model, nboot = 2000, cores = 2)
boot_paths <- as.data.frame(boot_results$paths)

## 4. Create significance stars based on p-values
boot_paths <- boot_paths %>%
  mutate(
    stars = case_when(
      p_val < 0.001 ~ "***",
      p_val < 0.01  ~ "**",
      p_val < 0.05  ~ "*",
      TRUE          ~ ""
    ),
    label = paste0(round(Original, 2), stars)
  )

## 5. Prepare a matrix of labels for semPlot
constructs <- rownames(pls_model$path_coefficients)
label_matrix <- matrix("", nrow = length(constructs), ncol = length(constructs),
                       dimnames = list(constructs, constructs))

for (i in seq_len(nrow(boot_paths))) {
  from <- str_split(boot_paths$Path[i], " -> ")[[1]][1]
  to   <- str_split(boot_paths$Path[i], " -> ")[[1]][2]
  label_matrix[from, to] <- boot_paths$label[i]
}

## 6. Add R² values to latent variable names
r2_vals <- pls_model$rSquared
constructs_with_r2 <- constructs
for (i in names(r2_vals)) {
  r2_val <- round(r2_vals[i], 2)
  constructs_with_r2[constructs_with_r2 == i] <- paste0(i, " (R²=", r2_val, ")")
}

## 7. Plot with semPaths using custom path labels & R² in construct names
semPaths(
  object         = pls_model,
  what           = "path",
  whatLabels     = "no",         # we'll override with custom labels
  edgeLabels     = label_matrix, # custom path labels
  style          = "lisrel",
  edge.label.cex = 1.2,
  sizeMan        = 6,
  sizeLat        = 8,
  residuals      = FALSE,
  intercepts     = FALSE,
  layout         = "tree",
  color          = list(lat = "lightblue", man = "white"),
  nCharNodes     = 0,
  asize          = 2,
  edge.color     = "black",
  nodeLabels     = constructs_with_r2  # add R² to node labels
)

## 8. Save the plot as PNG
png("pls_path_model_with_stars_r2.png", width = 1800, height = 1200, res = 150)
semPaths(
  object         = pls_model,
  what           = "path",
  whatLabels     = "no",
  edgeLabels     = label_matrix,
  style          = "lisrel",
  edge.label.cex = 1.2,
  sizeMan        = 6,
  sizeLat        = 8,
  residuals      = FALSE,
  intercepts     = FALSE,
  layout         = "tree",
  color          = list(lat = "lightblue", man = "white"),
  nCharNodes     = 0,
  asize          = 2,
  edge.color     = "black",
  nodeLabels     = constructs_with_r2
)
dev.off()

message("Plot saved as pls_path_model_with_stars_r2.png in your working directory")


--------------------------------------------------------------------------------------------------------------------------------------------------------------

# PL-SEM in R - Sample data - D Data - anonymized
## Objective 1

## 1. Set working directory and load in the data. Also view snippets of the data
setwd("C:\\Users\\Documents\\")
dt <- read_csv("data.csv", header = TRUE, sep = ",")
head(dt)
tail(dt)
View(dt)
glimpse(dt)
## 2. Install and load required packages 
if(!require(seminr)) install.packages("seminr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(semPlot)) install.packages("semPlot", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(dplyr)) install.packages("dplyr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(tibble)) install.packages("tibble", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(readr)) install.packages("readr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(ggplot2)) install.packages("ggplot2", repos="https://cloud.r-project.org")
library(tibble)
library(readr)
library(ggplot2)
library(seminr)
library(semPlot)
library(dplyr)

set.seed(123)

 ## 3. Define measurement model
mm <- constructs(
  composite("CE", multi_items("CE", 1:4), weights = mode_A()),                             # reflective (Mode A)
  composite("RA", multi_items("RA", 1:4), weights = mode_A()),
  composite("CA", multi_items("CA", 1:4), weights = mode_A()),
  composite("IC", multi_items("IC", 1:4), weights = mode_A()),
  composite("MA", multi_items("MA", 1:4), weights = mode_A()),
  composite("OR", single_items(c("LC", "NR", "CRA", "R")), weights = mode_A())
  
)

## 4. Structural model
sm <- relationships(
  paths(from = "CE", to = "OR"),
  paths(from = "CA", to = "OR"),
  paths(from = "RA", to = "OR"),
  paths(from = "IC", to = "OR"),
  paths(from = "MA", to = "OR")
)

## 5. Estimate model
pls_model <- estimate_pls(data = dt, measurement_model = mm, structural_model = sm)
summary(pls_model)

paths <- pls_model$path_coefficients
print(paths)

#### Alternatively:
##### pls_model <- estimate_pls(data = dt,
#####  measurement_model = corp_rep_mm,
####  structural_model  = corp_rep_sm,
 #### inner_weights = path_weighting,
 #### missing = mean_replacement,
  #### missing_value = "-99")


### 6. Summarizing the model
` # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.`
summary_pls_model <- summary(pls_model)

#### calling summary_corp_rep$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
summary_pls_model$paths

#### calling summary_corp_rep$reliability, we inspect the construct reliability metrics
summary_pls_model$reliability

#### we can plot the reliability
plot(summary_corp_rep$reliability)

#### calling summary_corp_rep$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
summary_pls_model$validity$fl_criteria

#### Calling summary_corp_rep$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
summary_pls_model$validity$htmt

### Calling summary_corp_rep$vif_antecedents, we inspect the VIF for collinerity
summary_pls_model$vif_antecedents

#### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
summary_pls_model$descriptives$statistics$items

##. Outer loadings (indicator reliability)
## outer_loadings <- pls_model$outer_loadings
## print(outer_loadings)

##. Construct scores (latent variable scores)
# construct_scores <- pls_model$scores
# head(construct_scores)

##. Reliability & AVE (convergent validity)
# reliab <- reliability(pls_model)
# print(reliab)

#### To get the construct statistics.
summary_pls_model$descriptives$statistics$constructs

boot_model <- bootstrap_model(seminr_model = corp_rep_pls_model,
  nboot = 1000,
  cores = NULL,
  seed = 123)
sum_boot_model <- summary(boot_model)

#### Obtain results on model estimates such as the path coefficients with sum_boot_corp_rep$bootstrapped_paths.
sum_boot_model$bootstrapped_paths

## 7. Convert PLS model to a semPlot-compatible object
# seminr doesn't directly integrate, so we adapt using lavaan-like format
# First, get path relationships
paths <- pls_model$path_coefficients
print(paths)

## 8. Get R² values for endogenous constructs
r2_vals <- pls_model$rSquared
print(r2_vals)

## 9. Use semPlot's semPaths function for visualization
semPaths(
  object       = pls_model,    # seminr model
  what         = "path",       # show path model
  whatLabels   = "est",        # show estimates
  style        = "lisrel",     # clean LISREL-style layout
  edge.label.cex = 1.0,        # font size for path coefficients
  sizeMan      = 6,            # indicator box size
  sizeLat      = 8,            # latent variable size
  residuals    = FALSE,        # hide residual arrows
  intercepts   = FALSE,        # hide intercepts
  layout       = "tree",       # top-down or left-right tree layout
  color        = list(lat = "lightblue", man = "yellow"), # node colors
  nCharNodes   = 0,            # don't shorten names
  asize        = 2,            # arrow thickness
  edge.color   = "black"       # arrow color
)


## 10. Save the plot as PNG
png("pls_path_model_publication_ready.png", width = 1600, height = 1000, res = 150)
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "est",
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "yellow"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)
dev.off()

## Extract path coefficients, standard errors, t-values, p-values from bootstrap
paths_table <- sum_boot_model$paths %>% as.data.frame()
# Make a neat CSV
write_csv(paths_table, "pls_path_coefficients_bootstrap.csv")


##  Objective 2
## 3. Define measurement model
mm <- constructs(
  composite("CE", multi_items("CE", 1:4), weights = mode_A()),                             # reflective (Mode A)
  composite("RA", multi_items("RA", 1:4), weights = mode_A()),
  composite("CA", multi_items("CA", 1:4), weights = mode_A()),
  composite("IC", multi_items("IC", 1:4), weights = mode_A()),
  composite("MA", multi_items("MA", 1:4), weights = mode_A()),
  composite("QFS", single_items(c("ECS", "ENS", "GT", "SS")), weights = mode_A())
  
)

## 4. Structural model
sm <- relationships(
  paths(from = "CE", to = "QFS"),
  paths(from = "CA", to = "QFS"),
  paths(from = "RA", to = "QFS"),
  paths(from = "IC", to = "QFS"),
  paths(from = "MA", to = "QFS")
)

## 5. Estimate model
pls_model <- estimate_pls(data = dt, measurement_model = mm, structural_model = sm)
summary(pls_model)

paths <- pls_model$path_coefficients
print(paths)

#### Alternatively:
##### pls_model <- estimate_pls(data = dt,
#####  measurement_model = corp_rep_mm,
####  structural_model  = corp_rep_sm,
 #### inner_weights = path_weighting,
 #### missing = mean_replacement,
  #### missing_value = "-99")


### 6. Summarizing the model
` # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.`
summary_pls_model <- summary(pls_model)

#### calling summary_corp_rep$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
summary_pls_model$paths

#### calling summary_corp_rep$reliability, we inspect the construct reliability metrics
summary_pls_model$reliability

#### we can plot the reliability
plot(summary_corp_rep$reliability)

#### calling summary_corp_rep$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
summary_pls_model$validity$fl_criteria

#### Calling summary_corp_rep$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
summary_pls_model$validity$htmt

### Calling summary_corp_rep$vif_antecedents, we inspect the VIF for collinerity
summary_pls_model$vif_antecedents

#### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
summary_pls_model$descriptives$statistics$items

##. Outer loadings (indicator reliability)
## outer_loadings <- pls_model$outer_loadings
## print(outer_loadings)

##. Construct scores (latent variable scores)
# construct_scores <- pls_model$scores
# head(construct_scores)

##. Reliability & AVE (convergent validity)
# reliab <- reliability(pls_model)
# print(reliab)

#### To get the construct statistics.
summary_pls_model$descriptives$statistics$constructs

boot_model <- bootstrap_model(seminr_model = corp_rep_pls_model,
  nboot = 1000,
  cores = NULL,
  seed = 123)
sum_boot_model <- summary(boot_model)

#### Obtain results on model estimates such as the path coefficients with sum_boot_corp_rep$bootstrapped_paths.
sum_boot_model$bootstrapped_paths

## 7. Convert PLS model to a semPlot-compatible object
# seminr doesn't directly integrate, so we adapt using lavaan-like format
# First, get path relationships
paths <- pls_model$path_coefficients
print(paths)

## 8. Get R² values for endogenous constructs
r2_vals <- pls_model$rSquared
print(r2_vals)

## 9. Use semPlot's semPaths function for visualization
semPaths(
  object       = pls_model,    # seminr model
  what         = "path",       # show path model
  whatLabels   = "est",        # show estimates
  style        = "lisrel",     # clean LISREL-style layout
  edge.label.cex = 1.0,        # font size for path coefficients
  sizeMan      = 6,            # indicator box size
  sizeLat      = 8,            # latent variable size
  residuals    = FALSE,        # hide residual arrows
  intercepts   = FALSE,        # hide intercepts
  layout       = "tree",       # top-down or left-right tree layout
  color        = list(lat = "lightblue", man = "yellow"), # node colors
  nCharNodes   = 0,            # don't shorten names
  asize        = 2,            # arrow thickness
  edge.color   = "black"       # arrow color
)


## 10. Save the plot as PNG
png("pls_path_model_publication_ready.png", width = 1600, height = 1000, res = 150)
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "est",
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "yellow"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)
dev.off()
## Extract path coefficients, standard errors, t-values, p-values from bootstrap
paths_table <- sum_boot_model$paths %>% as.data.frame()
# Make a neat CSV
write_csv(paths_table, "pls_path_coefficients_bootstrap.csv")


##  Objective 3
## 3. Define measurement model
mm <- constructs(
  composite("CE", multi_items("CE", 1:4), weights = mode_A()),                             # reflective (Mode A)
  composite("RA", multi_items("RA", 1:4), weights = mode_A()),
  composite("CA", multi_items("CA", 1:4), weights = mode_A()),
  composite("IC", multi_items("IC", 1:4), weights = mode_A()),
  composite("MA", multi_items("MA", 1:4), weights = mode_A()),
  composite("CRA", single_items(c("CRA", "ENS", "GT", "SS")), weights = mode_A())
  composite("R", multi_items("R", 1:4), weights = mode_A()),                             # reflective (Mode A)
  composite("LC", multi_items("LC", 1:4), weights = mode_A()),
  composite("NR", multi_items("NR", 1:4), weights = mode_A())

)

## 4. Structural model
sm <- relationships(
  paths(from = "CE", to = "QFS"),
  paths(from = "CA", to = "QFS"),
  paths(from = "RA", to = "QFS"),
  paths(from = "IC", to = "QFS"),
  paths(from = "MA", to = "QFS")
  paths(from = "CRA", to = "QFS")
  paths(from = "R", to = "QFS")
  paths(from = "LC", to = "QFS")
)

## 5. Estimate model
pls_model <- estimate_pls(data = dt, measurement_model = mm, structural_model = sm)
summary(pls_model)

paths <- pls_model$path_coefficients
print(paths)

#### Alternatively:
##### pls_model <- estimate_pls(data = dt,
#####  measurement_model = corp_rep_mm,
####  structural_model  = corp_rep_sm,
 #### inner_weights = path_weighting,
 #### missing = mean_replacement,
  #### missing_value = "-99")


### 6. Summarizing the model
` # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.`
summary_pls_model <- summary(pls_model)

#### calling summary_corp_rep$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
summary_pls_model$paths

#### calling summary_corp_rep$reliability, we inspect the construct reliability metrics
summary_pls_model$reliability

#### we can plot the reliability
plot(summary_corp_rep$reliability)

#### calling summary_corp_rep$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
summary_pls_model$validity$fl_criteria

#### Calling summary_corp_rep$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
summary_pls_model$validity$htmt

### Calling summary_corp_rep$vif_antecedents, we inspect the VIF for collinerity
summary_pls_model$vif_antecedents

#### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
summary_pls_model$descriptives$statistics$items

##. Outer loadings (indicator reliability)
## outer_loadings <- pls_model$outer_loadings
## print(outer_loadings)

##. Construct scores (latent variable scores)
# construct_scores <- pls_model$scores
# head(construct_scores)

##. Reliability & AVE (convergent validity)
# reliab <- reliability(pls_model)
# print(reliab)

#### To get the construct statistics.
summary_pls_model$descriptives$statistics$constructs

boot_model <- bootstrap_model(seminr_model = corp_rep_pls_model,
  nboot = 1000,
  cores = NULL,
  seed = 123)
sum_boot_model <- summary(boot_model)

#### Obtain results on model estimates such as the path coefficients with sum_boot_corp_rep$bootstrapped_paths.
sum_boot_model$bootstrapped_paths

## 7. Convert PLS model to a semPlot-compatible object
# seminr doesn't directly integrate, so we adapt using lavaan-like format
# First, get path relationships
paths <- pls_model$path_coefficients
print(paths)

## 8. Get R² values for endogenous constructs
r2_vals <- pls_model$rSquared
print(r2_vals)

## 9. Use semPlot's semPaths function for visualization
semPaths(
  object       = pls_model,    # seminr model
  what         = "path",       # show path model
  whatLabels   = "est",        # show estimates
  style        = "lisrel",     # clean LISREL-style layout
  edge.label.cex = 1.0,        # font size for path coefficients
  sizeMan      = 6,            # indicator box size
  sizeLat      = 8,            # latent variable size
  residuals    = FALSE,        # hide residual arrows
  intercepts   = FALSE,        # hide intercepts
  layout       = "tree",       # top-down or left-right tree layout
  color        = list(lat = "lightblue", man = "yellow"), # node colors
  nCharNodes   = 0,            # don't shorten names
  asize        = 2,            # arrow thickness
  edge.color   = "black"       # arrow color
)


## 10. Save the plot as PNG
png("pls_path_model_publication_ready.png", width = 1600, height = 1000, res = 150)
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "est",
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "yellow"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)
dev.off()

## Extract path coefficients, standard errors, t-values, p-values from bootstrap
paths_table <- sum_boot_model$paths %>% as.data.frame()
# Make a neat CSV
write_csv(paths_table, "pls_path_coefficients_bootstrap.csv")

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
# PL-SEM in R - Sample data - P Data - anonymized
## Objective 1

## 1. Set working directory and load in the data. Also view snippets of the data
setwd("C:\\Users\\Documents\\")
dt <- read_csv("data.csv", header = TRUE, sep = ",")
head(dt)
tail(dt)
View(dt)
glimpse(dt)
## 2. Install and load required packages 
if(!require(seminr)) install.packages("seminr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(semPlot)) install.packages("semPlot", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(dplyr)) install.packages("dplyr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(tibble)) install.packages("tibble", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(readr)) install.packages("readr", repos="https://cloud.r-project.org") # Skip if already installed
if(!require(ggplot2)) install.packages("ggplot2", repos="https://cloud.r-project.org")
library(tibble)
library(readr)
library(ggplot2)
library(seminr)
library(semPlot)
library(dplyr)

set.seed(123)

 ## 3. Define measurement model
mm <- constructs(
 
  composite("MAT", single_items(c("MAT-C", "MAT-A", "MAT-DAS", "MAT-E", "MAT-FAR")), weights = mode_A()),
  composite("OP", single_items(c("OP-CR", "OP-EP", "OP-FO", "OP-OA", "OP-SQ")), weights = mode_A())
  
)

## 4. Structural model
sm <- relationships(
  paths(from = "MAT", to = "OP")

## 5. Estimate model
pls_model <- estimate_pls(data = dt, measurement_model = mm, structural_model = sm)
summary(pls_model)

paths <- pls_model$path_coefficients
print(paths)

#### Alternatively:
##### pls_model <- estimate_pls(data = dt,
#####  measurement_model = corp_rep_mm,
####  structural_model  = corp_rep_sm,
 #### inner_weights = path_weighting,
 #### missing = mean_replacement,
  #### missing_value = "-99")


### 6. Summarizing the model
` # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.`
summary_pls_model <- summary(pls_model)

#### calling summary_corp_rep$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
summary_pls_model$paths

#### calling summary_corp_rep$reliability, we inspect the construct reliability metrics
summary_pls_model$reliability


#### we can plot the reliability
plot(summary_corp_rep$reliability)

#### calling summary_corp_rep$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
summary_pls_model$validity$fl_criteria

#### Calling summary_corp_rep$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
summary_pls_model$validity$htmt

### Calling summary_corp_rep$vif_antecedents, we inspect the VIF for collinerity
summary_pls_model$vif_antecedents

#### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
summary_pls_model$descriptives$statistics$items

##. Outer loadings (indicator reliability)
## outer_loadings <- pls_model$outer_loadings
## print(outer_loadings)

##. Construct scores (latent variable scores)
# construct_scores <- pls_model$scores
# head(construct_scores)

##. Reliability & AVE (convergent validity)
# reliab <- reliability(pls_model)
# print(reliab)

#### To get the construct statistics.
summary_pls_model$descriptives$statistics$constructs

### Bootstrapping
boot_model <- bootstrap_model(seminr_model = corp_rep_pls_model,
  nboot = 1000,
  cores = NULL,
  seed = 123)
sum_boot_model <- summary(boot_model)

#### Obtain results on model estimates such as the path coefficients with sum_boot_corp_rep$bootstrapped_paths.
sum_boot_model$bootstrapped_paths

## 7. Convert PLS model to a semPlot-compatible object
# seminr doesn't directly [additional code - SEMINR.txt](https://github.com/user-attachments/files/22310232/additional.code.-.SEMINR.txt)
integrate, so we adapt using lavaan-like format
# First, get path relationships
paths <- pls_model$path_coefficients
print(paths)

## 8. Get R² values for endogenous constructs
r2_vals <- pls_model$rSquared
print(r2_vals)

## 9. Use semPlot's semPaths function for visualization
semPaths(
  object       = pls_model,    # seminr model
  what         = "path",       # show path model
  whatLabels   = "est",        # show estimates
  style        = "lisrel",     # clean LISREL-style layout
  edge.label.cex = 1.0,        # font size for path coefficients
  sizeMan      = 6,            # indicator box size
  sizeLat      = 8,            # latent variable size
  residuals    = FALSE,        # hide residual arrows
  intercepts   = FALSE,        # hide intercepts
  layout       = "tree",       # top-down or left-right tree layout
  color        = list(lat = "lightblue", man = "yellow"), # node colors
  nCharNodes   = 0,            # don't shorten names
  asize        = 2,            # arrow thickness
  edge.color   = "black"       # arrow color
)


## 10. Save the plot as PNG
png("pls_path_model_publication_ready.png", width = 1600, height = 1000, res = 150)
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "est",
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "yellow"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)
dev.off()

## Extract path coefficients, standard errors, t-values, p-values from bootstrap
paths_table <- sum_boot_model$paths %>% as.data.frame()
# Make a neat CSV
write_csv(paths_table, "pls_path_coefficients_bootstrap.csv")


# Objective 2 - Mediation 
## Create the measurement model
mm_mod <- constructs(
 
  composite("MAT", single_items(c("MAT-C", "MAT-A", "MAT-DAS", "MAT-E", "MAT-FAR")), weights = mode_A())
  composite("OP", single_items(c("OP-CR", "OP-EP", "OP-FO", "OP-OA", "OP-SQ")), weights = mode_A()),
  composite("OP", single_items(c("OP-CR", "OP-EP", "OP-FO", "OP-OA", "OP-SQ")), weights = mode_A()),
  composite("FL", single_items(c("FL-TC", "FL-M", "FL-B", "FL-FD")), weights = mode_A()),
  interaction_term(iv = "OP", moderator = "FL", method = two_stage)) # You can also use methods like product_indicator or orthogonal

## Create the structural model
sm_mod <- relationships(
  paths(from = c("MAT"), to = OP),
  paths(from = c("MAT", "FL", "MAT*FL"), to = c("OP")) # Interaction of independent and moderating variable
)

` #Next, we estimate the model with estimate_pls(), store it to corp_rep_pls_model_mod and summarize it to sum_corp_rep_mod. Further, we also apply bootstrapping and summarize the bootstrapped model with an alpha level of 5% (summary(boot_corp_rep_mod, alpha = 0.05))`

## Estimate the new model with moderator
pl_sm_mod <- estimate_pls(
  data = dt,
  measurement_model = mm_mod,
  structural_model = sm_mod,
  missing = mean_replacement,
  missing_value = "-99"
)

## Extract the summary
summary_pls_mod <- summary(pl_sm_mod)

## Bootstrap the model
boot_pls_mod <- bootstrap_model(
  seminr_model = pl_sm_mod,
  nboot = 1000)

## Summarize the results of the bootstrap
summary_boot_pls_mod <- summary(boot_pls_mod, alpha = 0.05)

`# In order to evaluate the moderating effect, we inspect the bootstrapped_paths element in the sum_boot_corp_rep_mod object.`
summary_boot_pls_mod$bootstrapped_paths
` #To better comprehend the results of the moderator analysis, we use the slope_analysis() function to visualize the two-way interaction effect. Therefore, we specify the model (moderated_model = corp_rep_pls_model_mod), the dependent variable (dv = "CUSL"), the moderator (moderator = "SC"), and the independent variable (iv = "CUSA") as well as the legend’s position (leg_place = "bottomright").`
slope_analysis(
  moderated_model = pl_sm_mod,
  dv = "OP",
  moderator = "FL",
  iv = "MAT",
  leg_place = "bottomright")

## Extract path coefficients, standard errors, t-values, p-values from bootstrap
paths_table <- summary_boot_pls_mod$paths %>% as.data.frame()
# Make a neat CSV
write_csv(paths_table, "pls_path_coefficients_bootstrap.csv")




# Objective 3

 ## 3. Define measurement model
mm <- constructs(
 
  composite("MAT", single_items(c("MAT-CLOUD", "MAT-A", "MAT-DAS", "MAT-E", "MAT-FAR")), weights = mode_A()),
  composite("ITR", single_items(c("ITR-HS", "ITR-I", "ITR-SD", "ITR-S", "ITR-OF")), weights = mode_A())
  
)

## 4. Structural model
sm <- relationships(
  paths(from = "MAT", to = "ITR")

## 5. Estimate model
pls_model <- estimate_pls(data = dt, measurement_model = mm, structural_model = sm)
summary(pls_model)

paths <- pls_model$path_coefficients
print(paths)

#### Alternatively:
##### pls_model <- estimate_pls(data = dt,
#####  measurement_model = corp_rep_mm,
####  structural_model  = corp_rep_sm,
 #### inner_weights = path_weighting,
 #### missing = mean_replacement,
  #### missing_value = "-99")


### 6. Summarizing the model
` # Once the model has been estimated, a summarized report of the results can be generated by using the summary() function.`
summary_pls_model <- summary(pls_model)

#### calling summary_corp_rep$paths, we inspect the model’s path coefficients and the (adjusted) R2 values 
summary_pls_model$paths

#### calling summary_corp_rep$reliability, we inspect the construct reliability metrics
summary_pls_model$reliability


#### we can plot the reliability
plot(summary_corp_rep$reliability)

#### calling summary_corp_rep$validity$fl_criteria, we obtain Discriminant validty, specifically, Fornell-Larcker criterion (Fornell & Larcker, 1981)
summary_pls_model$validity$fl_criteria

#### Calling summary_corp_rep$validity$htmt, we inspect heterotrait-monotrait ratio (HTMT)
summary_pls_model$validity$htmt

### Calling summary_corp_rep$vif_antecedents, we inspect the VIF for collinerity
summary_pls_model$vif_antecedents

#### We can access summary statistics such as mean, standard deviation and number of missing values for the model’s items
summary_pls_model$descriptives$statistics$items

##. Outer loadings (indicator reliability)
## outer_loadings <- pls_model$outer_loadings
## print(outer_loadings)

##. Construct scores (latent variable scores)
# construct_scores <- pls_model$scores
# head(construct_scores)

##. Reliability & AVE (convergent validity)
# reliab <- reliability(pls_model)
# print(reliab)

#### To get the construct statistics.
summary_pls_model$descriptives$statistics$constructs

### Bootstrapping
boot_model <- bootstrap_model(seminr_model = corp_rep_pls_model,
  nboot = 1000,
  cores = NULL,
  seed = 123)
sum_boot_model <- summary(boot_model)

#### Obtain results on model estimates such as the path coefficients with sum_boot_corp_rep$bootstrapped_paths.
sum_boot_model$bootstrapped_paths

## 7. Convert PLS model to a semPlot-compatible object
# seminr doesn't directly integrate, so we adapt using lavaan-like format
# First, get path relationships
paths <- pls_model$path_coefficients
print(paths)

## 8. Get R² values for endogenous constructs
r2_vals <- pls_model$rSquared
print(r2_vals)

## 9. Use semPlot's semPaths function for visualization
semPaths(
  object       = pls_model,    # seminr model
  what         = "path",       # show path model
  whatLabels   = "est",        # show estimates
  style        = "lisrel",     # clean LISREL-style layout
  edge.label.cex = 1.0,        # font size for path coefficients
  sizeMan      = 6,            # indicator box size
  sizeLat      = 8,            # latent variable size
  residuals    = FALSE,        # hide residual arrows
  intercepts   = FALSE,        # hide intercepts
  layout       = "tree",       # top-down or left-right tree layout
  color        = list(lat = "lightblue", man = "yellow"), # node colors
  nCharNodes   = 0,            # don't shorten names
  asize        = 2,            # arrow thickness
  edge.color   = "black"       # arrow color
)


## 10. Save the plot as PNG
png("pls_path_model_publication_ready.png", width = 1600, height = 1000, res = 150)
semPaths(
  object       = pls_model,
  what         = "path",
  whatLabels   = "est",
  style        = "lisrel",
  edge.label.cex = 1.2,
  sizeMan      = 6,
  sizeLat      = 8,
  residuals    = FALSE,
  intercepts   = FALSE,
  layout       = "tree",
  color        = list(lat = "lightblue", man = "yellow"),
  nCharNodes   = 0,
  asize        = 2,
  edge.color   = "black"
)
dev.off()

## Extract path coefficients, standard errors, t-values, p-values from bootstrap
paths_table <- sum_boot_model$paths %>% as.data.frame()
# Make a neat CSV
write_csv(paths_table, "pls_path_coefficients_bootstrap.csv")

# Useful References
  ` # Zhao, X., Lynch, J. G., & Chen, Q. (2010). Reconsidering baron and kenny: Myths and truths about mediation analysis. Journal of Consumer Research, 37(2), 197–206. https://doi.org/10.1086/651257`


<img width="945" height="529" alt="mediation decision chart" src="https://github.com/user-attachments/assets/26502500-6986-4ff5-8e13-749885cb7f1e" />
`Figure 1: Mediation Analysis Decision Chart`


